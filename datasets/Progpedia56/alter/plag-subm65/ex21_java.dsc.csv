id,type,token,location,code
1,TRANSLATIONUNITDECLARATION,"/data/00000056/submissions/07533963_21_200800389/Ex21.java",,""
2,RECORDDECLARATION,"Ex21",Ex21.java(12:1-921:2),"public class Ex21 {

	static UndirectedGraph<Integer> primed;
	static boolean [] visited = new boolean [101];
	static double dou;
	

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		
		int n = in.nextInt();
		
		double [][] list = new double [n+1][2];
		
		Integer [] nodes = new Integer[n+1];
		
		
		UndirectedGraph<Integer> graph = new Ex21().new UndirectedGraph<Integer>();
		
		
		
		for(int x = 0; x < n ; x++){
			list[x][0] = Double.parseDouble(in.next());
			list[x][1] = Double.parseDouble(in.next());
			nodes[x] = new Integer(x);
			graph.addNode(nodes[x]);
		}
		
		for(int x = 0; x < n ; x++){
			
			for(int y = x + 1; y < n ; y++){
				
				double length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2));
				
				graph.addEdge(nodes[x], nodes[y], length);
				
			}
			
		}
		
		primed = Prim.mst(graph);
		
		
		//System.out.println(primed.size());
		//System.out.println(primed);
		
		visited[0] = true;
		Map<Integer, Double> map = primed.edgesFrom(nodes[0]);
		
		minimal(map);
		
		
		System.out.printf(""%.2f"", dou);
		System.out.println();
		in.close();
	}
	
	
	static void minimal(Map<Integer, Double> m){
		
		//System.out.println(m.toString());
		
		
		if(m.isEmpty()){
			return;
		}
		else{
			Set<Integer> keys = m.keySet();
			
			
			for(Integer key:keys){
				if(visited[key.intValue()] == false){
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}
				
				
			}
			return;
		}
		
	}
	
	

	public final static class Prim {
	    /**
	     * Given a connected undirected graph with real-valued edge costs,
	     * returns an MST of that graph.
	     *
	     * @param graph The graph from which to compute an MST.
	     * @return A spanning tree of the graph with minimum total weight.
	     */
	    public static <T> UndirectedGraph<T> mst(UndirectedGraph<T> graph) {
	        /* The Fibonacci heap we'll use to select nodes efficiently. */
	        FibonacciHeap<T> pq = new FibonacciHeap<T>();

	        /* This Fibonacci heap hands back internal handles to the nodes it
	         * stores.  This map will associate each node with its entry in the
	         * Fibonacci heap.
	         */
	        Map<T, FibonacciHeap.Entry<T>> entries = new HashMap<T, FibonacciHeap.Entry<T>>();

	        /* The graph which will hold the resulting MST. */
	        UndirectedGraph<T> result = new Ex21().new UndirectedGraph<T>();

	        /* As an edge case, if the graph is empty, just hand back the empty
	         * graph.
	         */
	        if (graph.isEmpty())
	            return result;

	        /* Pick an arbitrary starting node. */
	        T startNode = graph.iterator().next();

	        /* Add it as a node in the graph.  During this process, we'll use
	         * whether a node is in the result graph or not as a sentinel of
	         * whether it's already been picked.
	         */
	        result.addNode(startNode);

	        /* Begin by adding all outgoing edges of this start node to the
	         * Fibonacci heap.
	         */
	        addOutgoingEdges(startNode, graph, pq, result, entries);

	        /* Now, until we have added |V| - 1 edges to the graph, continously
	         * pick a node and determine which edge to add.
	         */
	        for (int i = 0; i < graph.size() - 1; ++i) {
	            /* Grab the cheapest node we can add. */
	            T toAdd = pq.dequeueMin().getValue();

	            /* Determine which edge we should pick to add to the MST.  We'll
	             * do this by getting the endpoint of the edge leaving the current
	             * node that's of minimum cost and that enters the visited edges.
	             */
	            T endpoint = minCostEndpoint(toAdd, graph, result);

	            /* Add this edge to the graph. */
	            result.addNode(toAdd);
	            result.addEdge(toAdd, endpoint, graph.edgeCost(toAdd, endpoint));

	            /* Explore outward from this node. */
	            addOutgoingEdges(toAdd, graph, pq, result, entries);
	        }

	        /* Hand back the generated graph. */
	        return result;
	    }

	    /**
	     * Given a node in the source graph and a set of nodes that we've visited
	     * so far, returns the minimum-cost edge from that node to some node that
	     * has been visited before.
	     *
	     * @param node The node that has not been considered yet.
	     * @param graph The original graph whose MST is being computed.
	     * @param result The resulting graph, used to check what has been visited
	     *               so far.
	     */
	    private static <T> T minCostEndpoint(T node, UndirectedGraph<T> graph, 
	                                         UndirectedGraph<T> result) {
	        /* Track the best endpoint so far and its cost, initially null and
	         * +infinity.
	         */
	        T endpoint = null;
	        double leastCost = Double.POSITIVE_INFINITY;

	        /* Scan each node, checking whether it's a candidate. */
	        for (Map.Entry<T, Double> entry : graph.edgesFrom(node).entrySet()) {
	            /* If the endpoint isn't in the nodes constructed so far, don't
	             * consider it.
	             */
	            if (!result.containsNode(entry.getKey())) continue;

	            /* If the edge costs more than what we know, skip it. */
	            if (entry.getValue() >= leastCost) continue;

	            /* Otherwise, update our guess to be this node. */
	            endpoint = entry.getKey();
	            leastCost = entry.getValue();
	        }

	        /* Hand back the result.  We're guaranteed to have found something,
	         * since otherwise we couldn't have dequeued this node.
	         */
	        return endpoint;
	    }

	    /**
	     * Given a node in the graph, updates the priorities of adjacent nodes to
	     * take these edges into account.  Due to some optimizations we make, this
	     * step takes in several parameters beyond what might seem initially
	     * required.  They are explained in the param section below.
	     *
	     * @param node The node to explore outward from.
	     * @param graph The graph whose MST is being computed, used so we can
	     *              get the edges to consider.
	     * @param pq The Fibonacci heap holding each endpoint.
	     * @param result The result graph.  We need this information so that we
	     *               don't try to update information on a node that has
	     *               already been considered and thus isn't in the queue.
	     * @param entries A map from nodes to their corresponding heap entries.
	     *                We need this so we can call decreaseKey on the correct
	     *                elements.
	     */
	    private static <T> void addOutgoingEdges(T node, UndirectedGraph<T> graph,
	                                             FibonacciHeap<T> pq,
	                                             UndirectedGraph<T> result,
	                                             Map<T, FibonacciHeap.Entry<T>> entries ) {
	        /* Start off by scanning over all edges emanating from our node. */
	        for (Map.Entry<T, Double> arc : graph.edgesFrom(node).entrySet()) {
	            /* Given this arc, there are four possibilities.
	             *
	             * 1. This endpoint has already been added to the graph.  If so,
	             *    we ignore the edge since it would form a cycle.
	             * 2. This endpoint is not in the graph and has never been in
	             *    the heap.  Then we add it to the heap.
	             * 3. This endpoint is in the graph, but this is a better edge.
	             *    Then we use decreaseKey to update its priority.
	             * 4. This endpoint is in the graph, but there is a better edge
	             *    to it.  In that case, we similarly ignore it.
	             */
	            if (result.containsNode(arc.getKey())) continue; // Case 1

	            if (!entries.containsKey(arc.getKey())) { // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }
	            else if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }

	            // Case 4 handled implicitly by doing nothing.
	        }
	    }
	}; 
	
	
	
	public final class UndirectedGraph<T> implements Iterable<T> {
	    /* A map from nodes in the graph to sets of outgoing edges.  Each
	     * set of edges is represented by a map from edges to doubles.
	     */
	    private final Map<T, Map<T, Double>> mGraph = new HashMap<T, Map<T, Double>>();

	    /**
	     * Adds a new node to the graph.  If the node already exists, this
	     * function is a no-op.
	     *
	     * @param node The node to add.
	     * @return Whether or not the node was added.
	     */
	    public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashMap<T, Double>());
	        return true;
	    }

	    /**
	     * Given two nodes and a length, adds an arc of that length between those
	     * nodes.  If the arc already existed, the length is updated to the
	     * specified value.  If either endpoint does not exist in the graph, throws
	     * a NoSuchElementException.
	     *
	     * @param one The first node.
	     * @param two The second node.
	     * @param length The length of the edge.
	     * @throws NoSuchElementException If either the start or destination nodes
	     *                                do not exist.
	     */
	    public void addEdge(T one, T two, double length) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Add the edge in both directions. */
	        mGraph.get(one).put(two, length);
	        mGraph.get(two).put(one, length);
	    }

	    /**
	     * Removes the edge between the indicated endpoints from the graph.  If the
	     * edge does not exist, this operation is a no-op.  If either endpoint does
	     * not exist, this throws a NoSuchElementException.
	     *
	     * @param one The start node.
	     * @param two The destination node.
	     * @throws NoSuchElementException If either node is not in the graph.
	     */
	    public void removeEdge(T one, T two) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Remove the edges from both adjacency lists. */
	        mGraph.get(one).remove(two);
	        mGraph.get(two).remove(one);
	    }

	    /**
	     * Given two endpoints, returns the cost of the edge between them.  If
	     * either endpoint does not exist in the graph, or if the edge is not
	     * contained in the graph, this throws a NoSuchElementException.
	     *
	     * @param one The first endpoint.
	     * @param two The second endpoint.
	     * @return The cost of the edge between the endpoints.
	     * @throws NoSuchElementException If the edge is not found or the endpoints
	     *                                are not nodes in the graph.
	     */
	    public double edgeCost(T one, T two) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");     
	        
	        /* Look up the edge between the two. */
	        Double result = mGraph.get(one).get(two);

	        /* If there is no edge here, report an error. */
	        if (result == null)
	            throw new NoSuchElementException(""Edge does not exist in the graph."");

	        /* Otherwise return the cost. */
	        return result;
	    }

	    /**
	     * Given a node in the graph, returns an immutable view of the edges
	     * leaving that node, as a map from endpoints to costs.
	     *
	     * @param node The node whose edges should be queried.
	     * @return An immutable view of the edges leaving that node.
	     * @throws NoSuchElementException If the node does not exist.
	     */
	    public Map<T, Double> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Map<T, Double> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException(""Source node does not exist."");

	        return Collections.unmodifiableMap(arcs);
	    }

	    /**
	     * Returns whether a given node is contained in the graph.
	     *
	     * @param The node to test for inclusion.
	     * @return Whether that node is contained in the graph.
	     */
	    public boolean containsNode(T node) {
	        return mGraph.containsKey(node);
	    }

	    /**
	     * Returns an iterator that can traverse the nodes in the graph.
	     *
	     * @return An iterator that traverses the nodes in the graph.
	     */
	    public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }

	    /**
	     * Returns the number of nodes in the graph.
	     *
	     * @return The number of nodes in the graph.
	     */
	    public int size() {
	        return mGraph.size();
	    }

	    /**
	     * Returns whether the graph is empty.
	     *
	     * @return Whether the graph is empty.
	     */
	    public boolean isEmpty() {
	        return mGraph.isEmpty();
	    }
	}
	
	
	public final static class FibonacciHeap<T> {
	    /* In order for all of the Fibonacci heap operations to complete in O(1),
	     * clients need to have O(1) access to any element in the heap.  We make
	     * this work by having each insertion operation produce a handle to the
	     * node in the tree.  In actuality, this handle is the node itself, but
	     * we guard against external modification by marking the internal fields
	     * private.
	     */
	    public static final class Entry<T> {
	        private int     mDegree = 0;       // Number of children
	        private boolean mIsMarked = false; // Whether this node is marked

	        private Entry<T> mNext;   // Next and previous elements in the list
	        private Entry<T> mPrev;

	        private Entry<T> mParent; // Parent in the tree, if any.

	        private Entry<T> mChild;  // Child node, if any.

	        private T      mElem;     // Element being stored here
	        private double mPriority; // Its priority

	        /**
	         * Returns the element represented by this heap entry.
	         *
	         * @return The element represented by this heap entry.
	         */
	        public T getValue() {
	            return mElem;
	        }
	        /**
	         * Sets the element associated with this heap entry.
	         *
	         * @param value The element to associate with this heap entry.
	         */
	        public void setValue(T value) {
	            mElem = value;
	        }

	        /**
	         * Returns the priority of this element.
	         *
	         * @return The priority of this element.
	         */
	        public double getPriority() {
	            return mPriority;
	        }

	        /**
	         * Constructs a new Entry that holds the given element with the indicated 
	         * priority.
	         *
	         * @param elem The element stored in this node.
	         * @param priority The priority of this element.
	         */
	        private Entry(T elem, double priority) {
	            mNext = mPrev = this;
	            mElem = elem;
	            mPriority = priority;
	        }
	    }

	    /* Pointer to the minimum element in the heap. */
	    private Entry<T> mMin = null;

	    /* Cached size of the heap, so we don't have to recompute this explicitly. */
	    private int mSize = 0;

	    /**
	     * Inserts the specified element into the Fibonacci heap with the specified
	     * priority.  Its priority must be a valid double, so you cannot set the
	     * priority to NaN.
	     *
	     * @param value The value to insert.
	     * @param priority Its priority, which must be valid.
	     * @return An Entry representing that element in the tree.
	     */
	    public Entry<T> enqueue(T value, double priority) {
	        checkPriority(priority);

	        /* Create the entry object, which is a circularly-linked list of length
	         * one.
	         */
	        Entry<T> result = new Entry<T>(value, priority);

	        /* Merge this singleton list with the tree list. */
	        mMin = mergeLists(mMin, result);

	        /* Increase the size of the heap; we just added something. */
	        ++mSize;

	        /* Return the reference to the new element. */
	        return result;
	    }

	    /**
	     * Returns an Entry object corresponding to the minimum element of the
	     * Fibonacci heap, throwing a NoSuchElementException if the heap is
	     * empty.
	     *
	     * @return The smallest element of the heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> min() {
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");
	        return mMin;
	    }

	    /**
	     * Returns whether the heap is empty.
	     *
	     * @return Whether the heap is empty.
	     */
	    public boolean isEmpty() {
	        return mMin == null;
	    }

	    /**
	     * Returns the number of elements in the heap.
	     *
	     * @return The number of elements in the heap.
	     */
	    public int size() {
	        return mSize;
	    }

	    /**
	     * Given two Fibonacci heaps, returns a new Fibonacci heap that contains
	     * all of the elements of the two heaps.  Each of the input heaps is
	     * destructively modified by having all its elements removed.  You can
	     * continue to use those heaps, but be aware that they will be empty
	     * after this call completes.
	     *
	     * @param one The first Fibonacci heap to merge.
	     * @param two The second Fibonacci heap to merge.
	     * @return A new FibonacciHeap containing all of the elements of both
	     *         heaps.
	     */
	    public static <T> FibonacciHeap<T> merge(FibonacciHeap<T> one, FibonacciHeap<T> two) {
	        /* Create a new FibonacciHeap to hold the result. */
	        FibonacciHeap<T> result = new FibonacciHeap<T>();

	        /* Merge the two Fibonacci heap root lists together.  This helper function
	         * also computes the min of the two lists, so we can store the result in
	         * the mMin field of the new heap.
	         */
	        result.mMin = mergeLists(one.mMin, two.mMin);

	        /* The size of the new heap is the sum of the sizes of the input heaps. */
	        result.mSize = one.mSize + two.mSize;

	        /* Clear the old heaps. */
	        one.mSize = two.mSize = 0;
	        one.mMin  = null;
	        two.mMin  = null;

	        /* Return the newly-merged heap. */
	        return result;
	    }

	    /**
	     * Dequeues and returns the minimum element of the Fibonacci heap.  If the
	     * heap is empty, this throws a NoSuchElementException.
	     *
	     * @return The smallest element of the Fibonacci heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> dequeueMin() {
	        /* Check for whether we're empty. */
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");

	        /* Otherwise, we're about to lose an element, so decrement the number of
	         * entries in this heap.
	         */
	        --mSize;

	        /* Grab the minimum element so we know what to return. */
	        Entry<T> minElem = mMin;

	        /* Now, we need to get rid of this element from the list of roots.  There
	         * are two cases to consider.  First, if this is the only element in the
	         * list of roots, we set the list of roots to be null by clearing mMin.
	         * Otherwise, if it's not null, then we write the elements next to the
	         * min element around the min element to remove it, then arbitrarily
	         * reassign the min.
	         */
	        if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }

	        /* Next, clear the parent fields of all of the min element's children,
	         * since they're about to become roots.  Because the elements are
	         * stored in a circular list, the traversal is a bit complex.
	         */
	        if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }

	        /* Next, splice the children of the root node into the topmost list, 
	         * then set mMin to point somewhere in that list.
	         */
	        mMin = mergeLists(mMin, minElem.mChild);

	        /* If there are no entries left, we're done. */
	        if (mMin == null) return minElem;

	        /* Next, we need to coalsce all of the roots so that there is only one
	         * tree of each degree.  To track trees of each size, we allocate an
	         * ArrayList where the entry at position i is either null or the 
	         * unique tree of degree i.
	         */
	        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();

	        /* We need to traverse the entire list, but since we're going to be
	         * messing around with it we have to be careful not to break our
	         * traversal order mid-stream.  One major challenge is how to detect
	         * whether we're visiting the same node twice.  To do this, we'll
	         * spent a bit of overhead adding all of the nodes to a list, and
	         * then will visit each element of this list in order.
	         */
	        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();

	        /* To add everything, we'll iterate across the elements until we
	         * find the first element twice.  We check this by looping while the
	         * list is empty or while the current element isn't the first element
	         * of that list.
	         */
	        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);

	        /* Traverse this list and perform the appropriate unioning steps. */
	        for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }
	        return minElem;
	    }

	    /**
	     * Decreases the key of the specified element to the new priority.  If the
	     * new priority is greater than the old priority, this function throws an
	     * IllegalArgumentException.  The new priority must be a finite double,
	     * so you cannot set the priority to be NaN, or +/- infinity.  Doing
	     * so also throws an IllegalArgumentException.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The element whose priority should be decreased.
	     * @param newPriority The new priority to associate with this entry.
	     * @throws IllegalArgumentException If the new priority exceeds the old
	     *         priority, or if the argument is not a finite double.
	     */
	    public void decreaseKey(Entry<T> entry, double newPriority) {
	        checkPriority(newPriority);
	        if (newPriority > entry.mPriority)
	            throw new IllegalArgumentException(""New priority exceeds old."");

	        /* Forward this to a helper function. */
	        decreaseKeyUnchecked(entry, newPriority);
	    }
	    
	    /**
	     * Deletes this Entry from the Fibonacci heap that contains it.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The entry to delete.
	     */
	    public void delete(Entry<T> entry) {
	        /* Use decreaseKey to drop the entry's key to -infinity.  This will
	         * guarantee that the node is cut and set to the global minimum.
	         */
	        decreaseKeyUnchecked(entry, Double.NEGATIVE_INFINITY);

	        /* Call dequeueMin to remove it. */
	        dequeueMin();
	    }

	    /**
	     * Utility function which, given a user-specified priority, checks whether
	     * it's a valid double and throws an IllegalArgumentException otherwise.
	     *
	     * @param priority The user's specified priority.
	     * @throws IllegalArgumentException If it is not valid.
	     */
	    private void checkPriority(double priority) {
	        if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + "" is invalid."");
	    }

	    /**
	     * Utility function which, given two pointers into disjoint circularly-
	     * linked lists, merges the two lists together into one circularly-linked
	     * list in O(1) time.  Because the lists may be empty, the return value
	     * is the only pointer that's guaranteed to be to an element of the
	     * resulting list.
	     *
	     * This function assumes that one and two are the minimum elements of the
	     * lists they are in, and returns a pointer to whichever is smaller.  If
	     * this condition does not hold, the return value is some arbitrary pointer
	     * into the doubly-linked list.
	     *
	     * @param one A pointer into one of the two linked lists.
	     * @param two A pointer into the other of the two linked lists.
	     * @return A pointer to the smallest element of the resulting list.
	     */
	    private static <T> Entry<T> mergeLists(Entry<T> one, Entry<T> two) {
	        /* There are four cases depending on whether the lists are null or not.
	         * We consider each separately.
	         */
	        if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }
	    }

	    /**
	     * Decreases the key of a node in the tree without doing any checking to ensure
	     * that the new priority is valid.
	     *
	     * @param entry The node whose key should be decreased.
	     * @param priority The node's new priority.
	     */
	    private void decreaseKeyUnchecked(Entry<T> entry, double priority) {
	        /* First, change the node's priority. */
	        entry.mPriority = priority;

	        /* If the node no longer has a higher priority than its parent, cut it.
	         * Note that this also means that if we try to run a delete operation
	         * that decreases the key to -infinity, it's guaranteed to cut the node
	         * from its parent.
	         */
	        if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);

	        /* If our new value is the new min, mark it as such.  Note that if we
	         * ended up decreasing the key in a way that ties the current minimum
	         * priority, this will change the min accordingly.
	         */
	        if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;
	    }

	    /**
	     * Cuts a node from its parent.  If the parent was already marked, recursively
	     * cuts that node from its parent as well.
	     *
	     * @param entry The node to cut from its parent.
	     */
	    private void cutNode(Entry<T> entry) {
	        /* Begin by clearing the node's mark, since we just cut it. */
	        entry.mIsMarked = false;

	        /* Base case: If the node has no parent, we're done. */
	        if (entry.mParent == null) return;

	        /* Rewire the node's siblings around it, if it has any siblings. */
	        if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }

	        /* If the node is the one identified by its parent as its child,
	         * we need to rewrite that pointer to point to some arbitrary other
	         * child.
	         */
	        if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }

	        /* Decrease the degree of the parent, since it just lost a child. */
	        --entry.mParent.mDegree;

	        /* Splice this tree into the root list by converting it to a singleton
	         * and invoking the merge subroutine.
	         */
	        entry.mPrev = entry.mNext = entry;
	        mMin = mergeLists(mMin, entry);

	        /* Mark the parent and recursively cut it if it's already been
	         * marked.
	         */
	        if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;

	        /* Clear the relocated node's parent; it's now a root. */
	        entry.mParent = null;
	    }
	}
	
}"
3,INCLUDEDECLARATION,"java.text.DecimalFormat",,""
4,INCLUDEDECLARATION,"java.util.ArrayList",,""
5,INCLUDEDECLARATION,"java.util.Collections",,""
6,INCLUDEDECLARATION,"java.util.HashMap",,""
7,INCLUDEDECLARATION,"java.util.Iterator",,""
8,INCLUDEDECLARATION,"java.util.List",,""
9,INCLUDEDECLARATION,"java.util.Map",,""
10,INCLUDEDECLARATION,"java.util.NoSuchElementException",,""
11,INCLUDEDECLARATION,"java.util.Scanner",,""
12,INCLUDEDECLARATION,"java.util.Set",,""
13,FIELDDECLARATION,"this",,""
14,FIELDDECLARATION,"primed",Ex21.java(14:2-14:41),"primed"
15,FIELDDECLARATION,"visited",Ex21.java(15:2-15:48),"visited = new boolean[101]"
16,FIELDDECLARATION,"dou",Ex21.java(16:2-16:20),"dou"
17,METHODDECLARATION,"main",Ex21.java(19:2-68:3),"public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		
		int n = in.nextInt();
		
		double [][] list = new double [n+1][2];
		
		Integer [] nodes = new Integer[n+1];
		
		
		UndirectedGraph<Integer> graph = new Ex21().new UndirectedGraph<Integer>();
		
		
		
		for(int x = 0; x < n ; x++){
			list[x][0] = Double.parseDouble(in.next());
			list[x][1] = Double.parseDouble(in.next());
			nodes[x] = new Integer(x);
			graph.addNode(nodes[x]);
		}
		
		for(int x = 0; x < n ; x++){
			
			for(int y = x + 1; y < n ; y++){
				
				double length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2));
				
				graph.addEdge(nodes[x], nodes[y], length);
				
			}
			
		}
		
		primed = Prim.mst(graph);
		
		
		//System.out.println(primed.size());
		//System.out.println(primed);
		
		visited[0] = true;
		Map<Integer, Double> map = primed.edgesFrom(nodes[0]);
		
		minimal(map);
		
		
		System.out.printf(""%.2f"", dou);
		System.out.println();
		in.close();
	}"
18,METHODDECLARATION,"minimal",Ex21.java(71:2-96:3),"static void minimal(Map<Integer, Double> m){
		
		//System.out.println(m.toString());
		
		
		if(m.isEmpty()){
			return;
		}
		else{
			Set<Integer> keys = m.keySet();
			
			
			for(Integer key:keys){
				if(visited[key.intValue()] == false){
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}
				
				
			}
			return;
		}
		
	}"
19,CONSTRUCTORDECLARATION,"Ex21",,""
20,RECORDDECLARATION,"Ex21.Prim",Ex21.java(100:2-251:3),"public final static class Prim {
	    /**
	     * Given a connected undirected graph with real-valued edge costs,
	     * returns an MST of that graph.
	     *
	     * @param graph The graph from which to compute an MST.
	     * @return A spanning tree of the graph with minimum total weight.
	     */
	    public static <T> UndirectedGraph<T> mst(UndirectedGraph<T> graph) {
	        /* The Fibonacci heap we'll use to select nodes efficiently. */
	        FibonacciHeap<T> pq = new FibonacciHeap<T>();

	        /* This Fibonacci heap hands back internal handles to the nodes it
	         * stores.  This map will associate each node with its entry in the
	         * Fibonacci heap.
	         */
	        Map<T, FibonacciHeap.Entry<T>> entries = new HashMap<T, FibonacciHeap.Entry<T>>();

	        /* The graph which will hold the resulting MST. */
	        UndirectedGraph<T> result = new Ex21().new UndirectedGraph<T>();

	        /* As an edge case, if the graph is empty, just hand back the empty
	         * graph.
	         */
	        if (graph.isEmpty())
	            return result;

	        /* Pick an arbitrary starting node. */
	        T startNode = graph.iterator().next();

	        /* Add it as a node in the graph.  During this process, we'll use
	         * whether a node is in the result graph or not as a sentinel of
	         * whether it's already been picked.
	         */
	        result.addNode(startNode);

	        /* Begin by adding all outgoing edges of this start node to the
	         * Fibonacci heap.
	         */
	        addOutgoingEdges(startNode, graph, pq, result, entries);

	        /* Now, until we have added |V| - 1 edges to the graph, continously
	         * pick a node and determine which edge to add.
	         */
	        for (int i = 0; i < graph.size() - 1; ++i) {
	            /* Grab the cheapest node we can add. */
	            T toAdd = pq.dequeueMin().getValue();

	            /* Determine which edge we should pick to add to the MST.  We'll
	             * do this by getting the endpoint of the edge leaving the current
	             * node that's of minimum cost and that enters the visited edges.
	             */
	            T endpoint = minCostEndpoint(toAdd, graph, result);

	            /* Add this edge to the graph. */
	            result.addNode(toAdd);
	            result.addEdge(toAdd, endpoint, graph.edgeCost(toAdd, endpoint));

	            /* Explore outward from this node. */
	            addOutgoingEdges(toAdd, graph, pq, result, entries);
	        }

	        /* Hand back the generated graph. */
	        return result;
	    }

	    /**
	     * Given a node in the source graph and a set of nodes that we've visited
	     * so far, returns the minimum-cost edge from that node to some node that
	     * has been visited before.
	     *
	     * @param node The node that has not been considered yet.
	     * @param graph The original graph whose MST is being computed.
	     * @param result The resulting graph, used to check what has been visited
	     *               so far.
	     */
	    private static <T> T minCostEndpoint(T node, UndirectedGraph<T> graph, 
	                                         UndirectedGraph<T> result) {
	        /* Track the best endpoint so far and its cost, initially null and
	         * +infinity.
	         */
	        T endpoint = null;
	        double leastCost = Double.POSITIVE_INFINITY;

	        /* Scan each node, checking whether it's a candidate. */
	        for (Map.Entry<T, Double> entry : graph.edgesFrom(node).entrySet()) {
	            /* If the endpoint isn't in the nodes constructed so far, don't
	             * consider it.
	             */
	            if (!result.containsNode(entry.getKey())) continue;

	            /* If the edge costs more than what we know, skip it. */
	            if (entry.getValue() >= leastCost) continue;

	            /* Otherwise, update our guess to be this node. */
	            endpoint = entry.getKey();
	            leastCost = entry.getValue();
	        }

	        /* Hand back the result.  We're guaranteed to have found something,
	         * since otherwise we couldn't have dequeued this node.
	         */
	        return endpoint;
	    }

	    /**
	     * Given a node in the graph, updates the priorities of adjacent nodes to
	     * take these edges into account.  Due to some optimizations we make, this
	     * step takes in several parameters beyond what might seem initially
	     * required.  They are explained in the param section below.
	     *
	     * @param node The node to explore outward from.
	     * @param graph The graph whose MST is being computed, used so we can
	     *              get the edges to consider.
	     * @param pq The Fibonacci heap holding each endpoint.
	     * @param result The result graph.  We need this information so that we
	     *               don't try to update information on a node that has
	     *               already been considered and thus isn't in the queue.
	     * @param entries A map from nodes to their corresponding heap entries.
	     *                We need this so we can call decreaseKey on the correct
	     *                elements.
	     */
	    private static <T> void addOutgoingEdges(T node, UndirectedGraph<T> graph,
	                                             FibonacciHeap<T> pq,
	                                             UndirectedGraph<T> result,
	                                             Map<T, FibonacciHeap.Entry<T>> entries ) {
	        /* Start off by scanning over all edges emanating from our node. */
	        for (Map.Entry<T, Double> arc : graph.edgesFrom(node).entrySet()) {
	            /* Given this arc, there are four possibilities.
	             *
	             * 1. This endpoint has already been added to the graph.  If so,
	             *    we ignore the edge since it would form a cycle.
	             * 2. This endpoint is not in the graph and has never been in
	             *    the heap.  Then we add it to the heap.
	             * 3. This endpoint is in the graph, but this is a better edge.
	             *    Then we use decreaseKey to update its priority.
	             * 4. This endpoint is in the graph, but there is a better edge
	             *    to it.  In that case, we similarly ignore it.
	             */
	            if (result.containsNode(arc.getKey())) continue; // Case 1

	            if (!entries.containsKey(arc.getKey())) { // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }
	            else if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }

	            // Case 4 handled implicitly by doing nothing.
	        }
	    }
	}"
21,RECORDDECLARATION,"Ex21.UndirectedGraph",Ex21.java(255:2-399:3),"public final class UndirectedGraph<T> implements Iterable<T> {
	    /* A map from nodes in the graph to sets of outgoing edges.  Each
	     * set of edges is represented by a map from edges to doubles.
	     */
	    private final Map<T, Map<T, Double>> mGraph = new HashMap<T, Map<T, Double>>();

	    /**
	     * Adds a new node to the graph.  If the node already exists, this
	     * function is a no-op.
	     *
	     * @param node The node to add.
	     * @return Whether or not the node was added.
	     */
	    public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashMap<T, Double>());
	        return true;
	    }

	    /**
	     * Given two nodes and a length, adds an arc of that length between those
	     * nodes.  If the arc already existed, the length is updated to the
	     * specified value.  If either endpoint does not exist in the graph, throws
	     * a NoSuchElementException.
	     *
	     * @param one The first node.
	     * @param two The second node.
	     * @param length The length of the edge.
	     * @throws NoSuchElementException If either the start or destination nodes
	     *                                do not exist.
	     */
	    public void addEdge(T one, T two, double length) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Add the edge in both directions. */
	        mGraph.get(one).put(two, length);
	        mGraph.get(two).put(one, length);
	    }

	    /**
	     * Removes the edge between the indicated endpoints from the graph.  If the
	     * edge does not exist, this operation is a no-op.  If either endpoint does
	     * not exist, this throws a NoSuchElementException.
	     *
	     * @param one The start node.
	     * @param two The destination node.
	     * @throws NoSuchElementException If either node is not in the graph.
	     */
	    public void removeEdge(T one, T two) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Remove the edges from both adjacency lists. */
	        mGraph.get(one).remove(two);
	        mGraph.get(two).remove(one);
	    }

	    /**
	     * Given two endpoints, returns the cost of the edge between them.  If
	     * either endpoint does not exist in the graph, or if the edge is not
	     * contained in the graph, this throws a NoSuchElementException.
	     *
	     * @param one The first endpoint.
	     * @param two The second endpoint.
	     * @return The cost of the edge between the endpoints.
	     * @throws NoSuchElementException If the edge is not found or the endpoints
	     *                                are not nodes in the graph.
	     */
	    public double edgeCost(T one, T two) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");     
	        
	        /* Look up the edge between the two. */
	        Double result = mGraph.get(one).get(two);

	        /* If there is no edge here, report an error. */
	        if (result == null)
	            throw new NoSuchElementException(""Edge does not exist in the graph."");

	        /* Otherwise return the cost. */
	        return result;
	    }

	    /**
	     * Given a node in the graph, returns an immutable view of the edges
	     * leaving that node, as a map from endpoints to costs.
	     *
	     * @param node The node whose edges should be queried.
	     * @return An immutable view of the edges leaving that node.
	     * @throws NoSuchElementException If the node does not exist.
	     */
	    public Map<T, Double> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Map<T, Double> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException(""Source node does not exist."");

	        return Collections.unmodifiableMap(arcs);
	    }

	    /**
	     * Returns whether a given node is contained in the graph.
	     *
	     * @param The node to test for inclusion.
	     * @return Whether that node is contained in the graph.
	     */
	    public boolean containsNode(T node) {
	        return mGraph.containsKey(node);
	    }

	    /**
	     * Returns an iterator that can traverse the nodes in the graph.
	     *
	     * @return An iterator that traverses the nodes in the graph.
	     */
	    public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }

	    /**
	     * Returns the number of nodes in the graph.
	     *
	     * @return The number of nodes in the graph.
	     */
	    public int size() {
	        return mGraph.size();
	    }

	    /**
	     * Returns whether the graph is empty.
	     *
	     * @return Whether the graph is empty.
	     */
	    public boolean isEmpty() {
	        return mGraph.isEmpty();
	    }
	}"
22,RECORDDECLARATION,"Ex21.FibonacciHeap",Ex21.java(402:2-919:3),"public final static class FibonacciHeap<T> {
	    /* In order for all of the Fibonacci heap operations to complete in O(1),
	     * clients need to have O(1) access to any element in the heap.  We make
	     * this work by having each insertion operation produce a handle to the
	     * node in the tree.  In actuality, this handle is the node itself, but
	     * we guard against external modification by marking the internal fields
	     * private.
	     */
	    public static final class Entry<T> {
	        private int     mDegree = 0;       // Number of children
	        private boolean mIsMarked = false; // Whether this node is marked

	        private Entry<T> mNext;   // Next and previous elements in the list
	        private Entry<T> mPrev;

	        private Entry<T> mParent; // Parent in the tree, if any.

	        private Entry<T> mChild;  // Child node, if any.

	        private T      mElem;     // Element being stored here
	        private double mPriority; // Its priority

	        /**
	         * Returns the element represented by this heap entry.
	         *
	         * @return The element represented by this heap entry.
	         */
	        public T getValue() {
	            return mElem;
	        }
	        /**
	         * Sets the element associated with this heap entry.
	         *
	         * @param value The element to associate with this heap entry.
	         */
	        public void setValue(T value) {
	            mElem = value;
	        }

	        /**
	         * Returns the priority of this element.
	         *
	         * @return The priority of this element.
	         */
	        public double getPriority() {
	            return mPriority;
	        }

	        /**
	         * Constructs a new Entry that holds the given element with the indicated 
	         * priority.
	         *
	         * @param elem The element stored in this node.
	         * @param priority The priority of this element.
	         */
	        private Entry(T elem, double priority) {
	            mNext = mPrev = this;
	            mElem = elem;
	            mPriority = priority;
	        }
	    }

	    /* Pointer to the minimum element in the heap. */
	    private Entry<T> mMin = null;

	    /* Cached size of the heap, so we don't have to recompute this explicitly. */
	    private int mSize = 0;

	    /**
	     * Inserts the specified element into the Fibonacci heap with the specified
	     * priority.  Its priority must be a valid double, so you cannot set the
	     * priority to NaN.
	     *
	     * @param value The value to insert.
	     * @param priority Its priority, which must be valid.
	     * @return An Entry representing that element in the tree.
	     */
	    public Entry<T> enqueue(T value, double priority) {
	        checkPriority(priority);

	        /* Create the entry object, which is a circularly-linked list of length
	         * one.
	         */
	        Entry<T> result = new Entry<T>(value, priority);

	        /* Merge this singleton list with the tree list. */
	        mMin = mergeLists(mMin, result);

	        /* Increase the size of the heap; we just added something. */
	        ++mSize;

	        /* Return the reference to the new element. */
	        return result;
	    }

	    /**
	     * Returns an Entry object corresponding to the minimum element of the
	     * Fibonacci heap, throwing a NoSuchElementException if the heap is
	     * empty.
	     *
	     * @return The smallest element of the heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> min() {
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");
	        return mMin;
	    }

	    /**
	     * Returns whether the heap is empty.
	     *
	     * @return Whether the heap is empty.
	     */
	    public boolean isEmpty() {
	        return mMin == null;
	    }

	    /**
	     * Returns the number of elements in the heap.
	     *
	     * @return The number of elements in the heap.
	     */
	    public int size() {
	        return mSize;
	    }

	    /**
	     * Given two Fibonacci heaps, returns a new Fibonacci heap that contains
	     * all of the elements of the two heaps.  Each of the input heaps is
	     * destructively modified by having all its elements removed.  You can
	     * continue to use those heaps, but be aware that they will be empty
	     * after this call completes.
	     *
	     * @param one The first Fibonacci heap to merge.
	     * @param two The second Fibonacci heap to merge.
	     * @return A new FibonacciHeap containing all of the elements of both
	     *         heaps.
	     */
	    public static <T> FibonacciHeap<T> merge(FibonacciHeap<T> one, FibonacciHeap<T> two) {
	        /* Create a new FibonacciHeap to hold the result. */
	        FibonacciHeap<T> result = new FibonacciHeap<T>();

	        /* Merge the two Fibonacci heap root lists together.  This helper function
	         * also computes the min of the two lists, so we can store the result in
	         * the mMin field of the new heap.
	         */
	        result.mMin = mergeLists(one.mMin, two.mMin);

	        /* The size of the new heap is the sum of the sizes of the input heaps. */
	        result.mSize = one.mSize + two.mSize;

	        /* Clear the old heaps. */
	        one.mSize = two.mSize = 0;
	        one.mMin  = null;
	        two.mMin  = null;

	        /* Return the newly-merged heap. */
	        return result;
	    }

	    /**
	     * Dequeues and returns the minimum element of the Fibonacci heap.  If the
	     * heap is empty, this throws a NoSuchElementException.
	     *
	     * @return The smallest element of the Fibonacci heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> dequeueMin() {
	        /* Check for whether we're empty. */
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");

	        /* Otherwise, we're about to lose an element, so decrement the number of
	         * entries in this heap.
	         */
	        --mSize;

	        /* Grab the minimum element so we know what to return. */
	        Entry<T> minElem = mMin;

	        /* Now, we need to get rid of this element from the list of roots.  There
	         * are two cases to consider.  First, if this is the only element in the
	         * list of roots, we set the list of roots to be null by clearing mMin.
	         * Otherwise, if it's not null, then we write the elements next to the
	         * min element around the min element to remove it, then arbitrarily
	         * reassign the min.
	         */
	        if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }

	        /* Next, clear the parent fields of all of the min element's children,
	         * since they're about to become roots.  Because the elements are
	         * stored in a circular list, the traversal is a bit complex.
	         */
	        if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }

	        /* Next, splice the children of the root node into the topmost list, 
	         * then set mMin to point somewhere in that list.
	         */
	        mMin = mergeLists(mMin, minElem.mChild);

	        /* If there are no entries left, we're done. */
	        if (mMin == null) return minElem;

	        /* Next, we need to coalsce all of the roots so that there is only one
	         * tree of each degree.  To track trees of each size, we allocate an
	         * ArrayList where the entry at position i is either null or the 
	         * unique tree of degree i.
	         */
	        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();

	        /* We need to traverse the entire list, but since we're going to be
	         * messing around with it we have to be careful not to break our
	         * traversal order mid-stream.  One major challenge is how to detect
	         * whether we're visiting the same node twice.  To do this, we'll
	         * spent a bit of overhead adding all of the nodes to a list, and
	         * then will visit each element of this list in order.
	         */
	        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();

	        /* To add everything, we'll iterate across the elements until we
	         * find the first element twice.  We check this by looping while the
	         * list is empty or while the current element isn't the first element
	         * of that list.
	         */
	        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);

	        /* Traverse this list and perform the appropriate unioning steps. */
	        for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }
	        return minElem;
	    }

	    /**
	     * Decreases the key of the specified element to the new priority.  If the
	     * new priority is greater than the old priority, this function throws an
	     * IllegalArgumentException.  The new priority must be a finite double,
	     * so you cannot set the priority to be NaN, or +/- infinity.  Doing
	     * so also throws an IllegalArgumentException.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The element whose priority should be decreased.
	     * @param newPriority The new priority to associate with this entry.
	     * @throws IllegalArgumentException If the new priority exceeds the old
	     *         priority, or if the argument is not a finite double.
	     */
	    public void decreaseKey(Entry<T> entry, double newPriority) {
	        checkPriority(newPriority);
	        if (newPriority > entry.mPriority)
	            throw new IllegalArgumentException(""New priority exceeds old."");

	        /* Forward this to a helper function. */
	        decreaseKeyUnchecked(entry, newPriority);
	    }
	    
	    /**
	     * Deletes this Entry from the Fibonacci heap that contains it.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The entry to delete.
	     */
	    public void delete(Entry<T> entry) {
	        /* Use decreaseKey to drop the entry's key to -infinity.  This will
	         * guarantee that the node is cut and set to the global minimum.
	         */
	        decreaseKeyUnchecked(entry, Double.NEGATIVE_INFINITY);

	        /* Call dequeueMin to remove it. */
	        dequeueMin();
	    }

	    /**
	     * Utility function which, given a user-specified priority, checks whether
	     * it's a valid double and throws an IllegalArgumentException otherwise.
	     *
	     * @param priority The user's specified priority.
	     * @throws IllegalArgumentException If it is not valid.
	     */
	    private void checkPriority(double priority) {
	        if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + "" is invalid."");
	    }

	    /**
	     * Utility function which, given two pointers into disjoint circularly-
	     * linked lists, merges the two lists together into one circularly-linked
	     * list in O(1) time.  Because the lists may be empty, the return value
	     * is the only pointer that's guaranteed to be to an element of the
	     * resulting list.
	     *
	     * This function assumes that one and two are the minimum elements of the
	     * lists they are in, and returns a pointer to whichever is smaller.  If
	     * this condition does not hold, the return value is some arbitrary pointer
	     * into the doubly-linked list.
	     *
	     * @param one A pointer into one of the two linked lists.
	     * @param two A pointer into the other of the two linked lists.
	     * @return A pointer to the smallest element of the resulting list.
	     */
	    private static <T> Entry<T> mergeLists(Entry<T> one, Entry<T> two) {
	        /* There are four cases depending on whether the lists are null or not.
	         * We consider each separately.
	         */
	        if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }
	    }

	    /**
	     * Decreases the key of a node in the tree without doing any checking to ensure
	     * that the new priority is valid.
	     *
	     * @param entry The node whose key should be decreased.
	     * @param priority The node's new priority.
	     */
	    private void decreaseKeyUnchecked(Entry<T> entry, double priority) {
	        /* First, change the node's priority. */
	        entry.mPriority = priority;

	        /* If the node no longer has a higher priority than its parent, cut it.
	         * Note that this also means that if we try to run a delete operation
	         * that decreases the key to -infinity, it's guaranteed to cut the node
	         * from its parent.
	         */
	        if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);

	        /* If our new value is the new min, mark it as such.  Note that if we
	         * ended up decreasing the key in a way that ties the current minimum
	         * priority, this will change the min accordingly.
	         */
	        if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;
	    }

	    /**
	     * Cuts a node from its parent.  If the parent was already marked, recursively
	     * cuts that node from its parent as well.
	     *
	     * @param entry The node to cut from its parent.
	     */
	    private void cutNode(Entry<T> entry) {
	        /* Begin by clearing the node's mark, since we just cut it. */
	        entry.mIsMarked = false;

	        /* Base case: If the node has no parent, we're done. */
	        if (entry.mParent == null) return;

	        /* Rewire the node's siblings around it, if it has any siblings. */
	        if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }

	        /* If the node is the one identified by its parent as its child,
	         * we need to rewrite that pointer to point to some arbitrary other
	         * child.
	         */
	        if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }

	        /* Decrease the degree of the parent, since it just lost a child. */
	        --entry.mParent.mDegree;

	        /* Splice this tree into the root list by converting it to a singleton
	         * and invoking the merge subroutine.
	         */
	        entry.mPrev = entry.mNext = entry;
	        mMin = mergeLists(mMin, entry);

	        /* Mark the parent and recursively cut it if it's already been
	         * marked.
	         */
	        if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;

	        /* Clear the relocated node's parent; it's now a root. */
	        entry.mParent = null;
	    }
	}"
23,VARIABLEDECLARATION,"this",,""
24,COMPOUNDSTATEMENT,"",Ex21.java(71:45-96:3),"{
		
		//System.out.println(m.toString());
		
		
		if(m.isEmpty()){
			return;
		}
		else{
			Set<Integer> keys = m.keySet();
			
			
			for(Integer key:keys){
				if(visited[key.intValue()] == false){
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}
				
				
			}
			return;
		}
		
	}"
25,PARAMVARIABLEDECLARATION,"m",Ex21.java(71:22-71:44),"Map<Integer, Double> m"
26,DECLAREDREFERENCEEXPRESSION,"m",Ex21.java(76:6-76:7),"m"
27,RETURNSTATEMENT,"",,""
28,IFSTATEMENT,"",Ex21.java(76:3-94:4),"if(m.isEmpty()){
			return;
		}
		else{
			Set<Integer> keys = m.keySet();
			
			
			for(Integer key:keys){
				if(visited[key.intValue()] == false){
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}
				
				
			}
			return;
		}"
29,MEMBERCALLEXPRESSION,"isEmpty",Ex21.java(76:6-76:17),"m.isEmpty()"
30,COMPOUNDSTATEMENT,"",Ex21.java(76:18-78:4),"{
			return;
		}"
31,COMPOUNDSTATEMENT,"",Ex21.java(79:7-94:4),"{
			Set<Integer> keys = m.keySet();
			
			
			for(Integer key:keys){
				if(visited[key.intValue()] == false){
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}
				
				
			}
			return;
		}"
32,RETURNSTATEMENT,"",Ex21.java(77:4-77:11),"return;"
33,DECLAREDREFERENCEEXPRESSION,"m",Ex21.java(80:24-80:25),"m"
34,DECLARATIONSTATEMENT,"",Ex21.java(80:4-80:35),"Set<Integer> keys = m.keySet();"
35,FOREACHSTATEMENT,"",Ex21.java(83:4-92:5),"for(Integer key:keys){
				if(visited[key.intValue()] == false){
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}
				
				
			}"
36,RETURNSTATEMENT,"",Ex21.java(93:4-93:11),"return;"
37,VARIABLEDECLARATION,"keys",Ex21.java(80:17-80:34),"keys = m.keySet()"
38,DECLAREDREFERENCEEXPRESSION,"keys",Ex21.java(83:20-83:24),"keys"
39,MEMBERCALLEXPRESSION,"keySet",Ex21.java(80:24-80:34),"m.keySet()"
40,DECLAREDREFERENCEEXPRESSION,"keySet",Ex21.java(80:26-80:32),"keySet"
41,DECLARATIONSTATEMENT,"",Ex21.java(83:8-83:19),"Integer key"
42,COMPOUNDSTATEMENT,"",Ex21.java(83:25-92:5),"{
				if(visited[key.intValue()] == false){
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}
				
				
			}"
43,VARIABLEDECLARATION,"key",Ex21.java(83:16-83:19),"key"
44,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(84:8-84:15),"Ex21"
45,IFSTATEMENT,"",Ex21.java(84:5-89:6),"if(visited[key.intValue()] == false){
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}"
46,COMPOUNDSTATEMENT,"",Ex21.java(84:41-89:6),"{
					double a = m.get(key);
					visited[key.intValue()] = true;
					dou = dou + a;
					minimal(primed.edgesFrom(key));
				}"
47,BINARYOPERATOR,"==",Ex21.java(84:8-84:40),"visited[key.intValue()] == false"
48,DECLAREDREFERENCEEXPRESSION,"m",Ex21.java(85:17-85:18),"m"
49,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(84:8-84:31),"visited[key.intValue()]"
50,LITERAL,"",Ex21.java(84:35-84:40),"false"
51,MEMBEREXPRESSION,"visited",Ex21.java(84:8-84:15),"visited"
52,MEMBERCALLEXPRESSION,"intValue",Ex21.java(84:16-84:30),"key.intValue()"
53,DECLAREDREFERENCEEXPRESSION,"intValue",Ex21.java(84:20-84:28),"intValue"
54,DECLAREDREFERENCEEXPRESSION,"key",Ex21.java(84:16-84:19),"key"
55,DECLARATIONSTATEMENT,"",Ex21.java(85:6-85:28),"double a = m.get(key);"
56,BINARYOPERATOR,"=",Ex21.java(86:6-86:37),"visited[key.intValue()] = true;"
57,BINARYOPERATOR,"=",Ex21.java(87:6-87:20),"dou = dou + a;"
58,CALLEXPRESSION,"minimal",Ex21.java(88:6-88:37),"minimal(primed.edgesFrom(key));"
59,VARIABLEDECLARATION,"a",Ex21.java(85:13-85:27),"a = m.get(key)"
60,METHODDECLARATION,"minimal",Ex21.java(66:2-88:3),"static double minimal(Map<Integer, Double> m){
		
		//System.out.println(m.toString());
		
		if(m.isEmpty()){
			return 0;
		}
		else{
			Set<Integer> keys = m.keySet();
			
			for(Integer key:keys){
				if(visited[key.intValue()] == false){
					double dou = m.get(key);
					visited[key.intValue()] = true;
					return dou + minimal(primed.edgesFrom(key));
				}
				
				
			}
			return 0;
		}
		
	}"
61,MEMBERCALLEXPRESSION,"edgesFrom",Ex21.java(88:14-88:35),"primed.edgesFrom(key)"
62,DECLAREDREFERENCEEXPRESSION,"edgesFrom",Ex21.java(88:21-88:30),"edgesFrom"
63,METHODDECLARATION,"edgesFrom",,""
64,PARAMVARIABLEDECLARATION,"m",Ex21.java(66:24-66:46),"Map<Integer, Double> m"
65,DECLAREDREFERENCEEXPRESSION,"key",Ex21.java(88:31-88:34),"key"
66,MEMBEREXPRESSION,"primed",Ex21.java(88:14-88:20),"primed"
67,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(88:14-88:20),"Ex21"
68,PARAMVARIABLEDECLARATION,"java.lang.integer0",,""
69,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(86:6-86:29),"visited[key.intValue()]"
70,LITERAL,"",Ex21.java(86:32-86:36),"true"
71,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(87:6-87:9),"Ex21"
72,MEMBEREXPRESSION,"visited",Ex21.java(86:6-86:13),"visited"
73,MEMBERCALLEXPRESSION,"intValue",Ex21.java(86:14-86:28),"key.intValue()"
74,DECLAREDREFERENCEEXPRESSION,"intValue",Ex21.java(86:18-86:26),"intValue"
75,DECLAREDREFERENCEEXPRESSION,"key",Ex21.java(86:14-86:17),"key"
76,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(86:6-86:13),"Ex21"
77,MEMBEREXPRESSION,"dou",Ex21.java(87:6-87:9),"dou"
78,BINARYOPERATOR,"+",Ex21.java(87:12-87:19),"dou + a"
79,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(87:12-87:15),"Ex21"
80,MEMBEREXPRESSION,"dou",Ex21.java(87:12-87:15),"dou"
81,DECLAREDREFERENCEEXPRESSION,"a",Ex21.java(87:18-87:19),"a"
82,MEMBERCALLEXPRESSION,"get",Ex21.java(85:17-85:27),"m.get(key)"
83,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(85:19-85:22),"get"
84,DECLAREDREFERENCEEXPRESSION,"key",Ex21.java(85:23-85:26),"key"
85,UNINITIALIZEDVALUE,"Uninitialized Value",,""
86,DECLAREDREFERENCEEXPRESSION,"isEmpty",Ex21.java(76:8-76:15),"isEmpty"
87,VARIABLEDECLARATION,"this",,""
88,COMPOUNDSTATEMENT,"",Ex21.java(19:41-68:3),"{
		
		Scanner in = new Scanner(System.in);
		
		int n = in.nextInt();
		
		double [][] list = new double [n+1][2];
		
		Integer [] nodes = new Integer[n+1];
		
		
		UndirectedGraph<Integer> graph = new Ex21().new UndirectedGraph<Integer>();
		
		
		
		for(int x = 0; x < n ; x++){
			list[x][0] = Double.parseDouble(in.next());
			list[x][1] = Double.parseDouble(in.next());
			nodes[x] = new Integer(x);
			graph.addNode(nodes[x]);
		}
		
		for(int x = 0; x < n ; x++){
			
			for(int y = x + 1; y < n ; y++){
				
				double length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2));
				
				graph.addEdge(nodes[x], nodes[y], length);
				
			}
			
		}
		
		primed = Prim.mst(graph);
		
		
		//System.out.println(primed.size());
		//System.out.println(primed);
		
		visited[0] = true;
		Map<Integer, Double> map = primed.edgesFrom(nodes[0]);
		
		minimal(map);
		
		
		System.out.printf(""%.2f"", dou);
		System.out.println();
		in.close();
	}"
89,PARAMVARIABLEDECLARATION,"args",Ex21.java(19:26-19:39),"String[] args"
90,DECLAREDREFERENCEEXPRESSION,"System",Ex21.java(21:28-21:34),"System"
91,RETURNSTATEMENT,"",,""
92,DECLARATIONSTATEMENT,"",Ex21.java(21:3-21:39),"Scanner in = new Scanner(System.in);"
93,DECLARATIONSTATEMENT,"",Ex21.java(23:3-23:24),"int n = in.nextInt();"
94,DECLARATIONSTATEMENT,"",Ex21.java(25:3-25:42),"double [][] list = new double [n+1][2];"
95,DECLARATIONSTATEMENT,"",Ex21.java(27:3-27:39),"Integer [] nodes = new Integer[n+1];"
96,DECLARATIONSTATEMENT,"",Ex21.java(30:3-30:78),"UndirectedGraph<Integer> graph = new Ex21().new UndirectedGraph<Integer>();"
97,FORSTATEMENT,"",Ex21.java(34:3-39:4),"for(int x = 0; x < n ; x++){
			list[x][0] = Double.parseDouble(in.next());
			list[x][1] = Double.parseDouble(in.next());
			nodes[x] = new Integer(x);
			graph.addNode(nodes[x]);
		}"
98,FORSTATEMENT,"",Ex21.java(41:3-51:4),"for(int x = 0; x < n ; x++){
			
			for(int y = x + 1; y < n ; y++){
				
				double length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2));
				
				graph.addEdge(nodes[x], nodes[y], length);
				
			}
			
		}"
99,BINARYOPERATOR,"=",Ex21.java(53:3-53:28),"primed = Prim.mst(graph);"
100,BINARYOPERATOR,"=",Ex21.java(59:3-59:21),"visited[0] = true;"
101,DECLARATIONSTATEMENT,"",Ex21.java(60:3-60:57),"Map<Integer, Double> map = primed.edgesFrom(nodes[0]);"
102,CALLEXPRESSION,"minimal",Ex21.java(62:3-62:16),"minimal(map);"
103,MEMBERCALLEXPRESSION,"printf",Ex21.java(65:3-65:34),"System.out.printf(""%.2f"", dou);"
104,MEMBERCALLEXPRESSION,"println",Ex21.java(66:3-66:24),"System.out.println();"
105,MEMBERCALLEXPRESSION,"close",Ex21.java(67:3-67:14),"in.close();"
106,VARIABLEDECLARATION,"in",Ex21.java(21:11-21:38),"in = new Scanner(System.in)"
107,VARIABLEDECLARATION,"n",Ex21.java(23:7-23:23),"n = in.nextInt()"
108,VARIABLEDECLARATION,"list",Ex21.java(25:15-25:41),"list = new double [n+1][2]"
109,VARIABLEDECLARATION,"nodes",Ex21.java(27:14-27:38),"nodes = new Integer[n+1]"
110,VARIABLEDECLARATION,"graph",Ex21.java(30:28-30:77),"graph = new Ex21().new UndirectedGraph<Integer>()"
111,VARIABLEDECLARATION,"map",Ex21.java(60:24-60:56),"map = primed.edgesFrom(nodes[0])"
112,DECLAREDREFERENCEEXPRESSION,"println",Ex21.java(66:14-66:21),"println"
113,DECLAREDREFERENCEEXPRESSION,"in",Ex21.java(67:3-67:5),"in"
114,MEMBEREXPRESSION,"out",Ex21.java(66:3-66:13),"System.out"
115,DECLAREDREFERENCEEXPRESSION,"System",Ex21.java(66:3-66:9),"System"
116,MEMBERCALLEXPRESSION,"edgesFrom",Ex21.java(60:30-60:56),"primed.edgesFrom(nodes[0])"
117,DECLAREDREFERENCEEXPRESSION,"edgesFrom",Ex21.java(60:37-60:46),"edgesFrom"
118,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(60:47-60:55),"nodes[0]"
119,DECLAREDREFERENCEEXPRESSION,"nodes",Ex21.java(60:47-60:52),"nodes"
120,LITERAL,"",Ex21.java(60:53-60:54),"0"
121,MEMBEREXPRESSION,"primed",Ex21.java(60:30-60:36),"primed"
122,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(60:30-60:36),"Ex21"
123,NEWEXPRESSION,"",Ex21.java(21:16-21:38),"new Scanner(System.in)"
124,CONSTRUCTEXPRESSION,"",Ex21.java(21:16-21:38),"new Scanner(System.in)"
125,MEMBEREXPRESSION,"in",Ex21.java(21:28-21:37),"System.in"
126,DECLAREDREFERENCEEXPRESSION,"map",Ex21.java(62:11-62:14),"map"
127,DECLAREDREFERENCEEXPRESSION,"System",Ex21.java(65:3-65:9),"System"
128,DECLAREDREFERENCEEXPRESSION,"close",Ex21.java(67:6-67:11),"close"
129,ARRAYCREATIONEXPRESSION,"",Ex21.java(27:22-27:38),"new Integer[n+1]"
130,BINARYOPERATOR,"+",Ex21.java(27:34-27:37),"n+1"
131,DECLAREDREFERENCEEXPRESSION,"n",Ex21.java(27:34-27:35),"n"
132,LITERAL,"",Ex21.java(27:36-27:37),"1"
133,LITERAL,"",Ex21.java(34:15-34:16),"0"
134,DECLAREDREFERENCEEXPRESSION,"in",Ex21.java(23:11-23:13),"in"
135,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(59:3-59:13),"visited[0]"
136,LITERAL,"",Ex21.java(59:16-59:20),"true"
137,MEMBEREXPRESSION,"visited",Ex21.java(59:3-59:10),"visited"
138,LITERAL,"",Ex21.java(59:11-59:12),"0"
139,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(59:3-59:10),"Ex21"
140,ARRAYCREATIONEXPRESSION,"",Ex21.java(25:22-25:41),"new double [n+1][2]"
141,BINARYOPERATOR,"+",Ex21.java(25:34-25:37),"n+1"
142,LITERAL,"",Ex21.java(25:39-25:40),"2"
143,DECLAREDREFERENCEEXPRESSION,"n",Ex21.java(25:34-25:35),"n"
144,LITERAL,"",Ex21.java(25:36-25:37),"1"
145,MEMBERCALLEXPRESSION,"nextInt",Ex21.java(23:11-23:23),"in.nextInt()"
146,DECLAREDREFERENCEEXPRESSION,"nextInt",Ex21.java(23:14-23:21),"nextInt"
147,COMPOUNDSTATEMENT,"",Ex21.java(34:30-39:4),"{
			list[x][0] = Double.parseDouble(in.next());
			list[x][1] = Double.parseDouble(in.next());
			nodes[x] = new Integer(x);
			graph.addNode(nodes[x]);
		}"
148,DECLARATIONSTATEMENT,"",Ex21.java(34:7-34:16),"int x = 0"
149,BINARYOPERATOR,"<",Ex21.java(34:18-34:23),"x < n"
150,UNARYOPERATOR,"++",Ex21.java(34:26-34:29),"x++"
151,VARIABLEDECLARATION,"x",Ex21.java(34:11-34:16),"x = 0"
152,DECLAREDREFERENCEEXPRESSION,"list",Ex21.java(35:4-35:8),"list"
153,LITERAL,"",Ex21.java(41:15-41:16),"0"
154,BINARYOPERATOR,"=",Ex21.java(35:4-35:47),"list[x][0] = Double.parseDouble(in.next());"
155,BINARYOPERATOR,"=",Ex21.java(36:4-36:47),"list[x][1] = Double.parseDouble(in.next());"
156,BINARYOPERATOR,"=",Ex21.java(37:4-37:30),"nodes[x] = new Integer(x);"
157,MEMBERCALLEXPRESSION,"addNode",Ex21.java(38:4-38:28),"graph.addNode(nodes[x]);"
158,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(34:26-34:27),"x"
159,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(36:4-36:14),"list[x][1]"
160,STATICCALLEXPRESSION,"parseDouble",Ex21.java(36:17-36:46),"Double.parseDouble(in.next())"
161,DECLAREDREFERENCEEXPRESSION,"nodes",Ex21.java(37:4-37:9),"nodes"
162,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(36:4-36:11),"list[x]"
163,LITERAL,"",Ex21.java(36:12-36:13),"1"
164,DECLAREDREFERENCEEXPRESSION,"in",Ex21.java(36:36-36:38),"in"
165,DECLAREDREFERENCEEXPRESSION,"list",Ex21.java(36:4-36:8),"list"
166,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(36:9-36:10),"x"
167,MEMBERCALLEXPRESSION,"next",Ex21.java(36:36-36:45),"in.next()"
168,DECLAREDREFERENCEEXPRESSION,"next",Ex21.java(36:39-36:43),"next"
169,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(37:4-37:12),"nodes[x]"
170,NEWEXPRESSION,"",Ex21.java(37:15-37:29),"new Integer(x)"
171,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(38:4-38:9),"graph"
172,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(37:10-37:11),"x"
173,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(37:27-37:28),"x"
174,CONSTRUCTEXPRESSION,"",Ex21.java(37:15-37:29),"new Integer(x)"
175,DECLAREDREFERENCEEXPRESSION,"addNode",Ex21.java(38:10-38:17),"addNode"
176,METHODDECLARATION,"addNode",,""
177,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(38:18-38:26),"nodes[x]"
178,DECLAREDREFERENCEEXPRESSION,"nodes",Ex21.java(38:18-38:23),"nodes"
179,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(38:24-38:25),"x"
180,PARAMVARIABLEDECLARATION,"java.lang.integer0",,""
181,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(35:4-35:14),"list[x][0]"
182,STATICCALLEXPRESSION,"parseDouble",Ex21.java(35:17-35:46),"Double.parseDouble(in.next())"
183,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(35:4-35:11),"list[x]"
184,LITERAL,"",Ex21.java(35:12-35:13),"0"
185,DECLAREDREFERENCEEXPRESSION,"in",Ex21.java(35:36-35:38),"in"
186,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(35:9-35:10),"x"
187,MEMBERCALLEXPRESSION,"next",Ex21.java(35:36-35:45),"in.next()"
188,DECLAREDREFERENCEEXPRESSION,"next",Ex21.java(35:39-35:43),"next"
189,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(34:18-34:19),"x"
190,DECLAREDREFERENCEEXPRESSION,"n",Ex21.java(34:22-34:23),"n"
191,NEWEXPRESSION,"",Ex21.java(30:36-30:77),"new Ex21().new UndirectedGraph<Integer>()"
192,CONSTRUCTEXPRESSION,"",Ex21.java(30:36-30:77),"new Ex21().new UndirectedGraph<Integer>()"
193,CONSTRUCTORDECLARATION,"Ex21.UndirectedGraph",,""
194,COMPOUNDSTATEMENT,"",Ex21.java(41:30-51:4),"{
			
			for(int y = x + 1; y < n ; y++){
				
				double length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2));
				
				graph.addEdge(nodes[x], nodes[y], length);
				
			}
			
		}"
195,DECLARATIONSTATEMENT,"",Ex21.java(41:7-41:16),"int x = 0"
196,BINARYOPERATOR,"<",Ex21.java(41:18-41:23),"x < n"
197,UNARYOPERATOR,"++",Ex21.java(41:26-41:29),"x++"
198,VARIABLEDECLARATION,"x",Ex21.java(41:11-41:16),"x = 0"
199,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(43:16-43:17),"x"
200,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(53:3-53:9),"Ex21"
201,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(41:18-41:19),"x"
202,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(41:26-41:27),"x"
203,FORSTATEMENT,"",Ex21.java(43:4-49:5),"for(int y = x + 1; y < n ; y++){
				
				double length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2));
				
				graph.addEdge(nodes[x], nodes[y], length);
				
			}"
204,COMPOUNDSTATEMENT,"",Ex21.java(43:35-49:5),"{
				
				double length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2));
				
				graph.addEdge(nodes[x], nodes[y], length);
				
			}"
205,DECLARATIONSTATEMENT,"",Ex21.java(43:8-43:21),"int y = x + 1"
206,BINARYOPERATOR,"<",Ex21.java(43:23-43:28),"y < n"
207,UNARYOPERATOR,"++",Ex21.java(43:31-43:34),"y++"
208,VARIABLEDECLARATION,"y",Ex21.java(43:12-43:21),"y = x + 1"
209,DECLAREDREFERENCEEXPRESSION,"list",Ex21.java(45:41-45:45),"list"
210,BINARYOPERATOR,"+",Ex21.java(43:16-43:21),"x + 1"
211,LITERAL,"",Ex21.java(43:20-43:21),"1"
212,DECLAREDREFERENCEEXPRESSION,"y",Ex21.java(43:23-43:24),"y"
213,DECLARATIONSTATEMENT,"",Ex21.java(45:5-45:108),"double length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2));"
214,MEMBERCALLEXPRESSION,"addEdge",Ex21.java(47:5-47:47),"graph.addEdge(nodes[x], nodes[y], length);"
215,VARIABLEDECLARATION,"length",Ex21.java(45:12-45:107),"length = Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2))"
216,DECLAREDREFERENCEEXPRESSION,"y",Ex21.java(43:31-43:32),"y"
217,DECLAREDREFERENCEEXPRESSION,"addEdge",Ex21.java(47:11-47:18),"addEdge"
218,METHODDECLARATION,"addEdge",,""
219,DECLAREDREFERENCEEXPRESSION,"length",Ex21.java(47:39-47:45),"length"
220,PARAMVARIABLEDECLARATION,"double2",,""
221,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(47:29-47:37),"nodes[y]"
222,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(47:19-47:27),"nodes[x]"
223,DECLAREDREFERENCEEXPRESSION,"nodes",Ex21.java(47:19-47:24),"nodes"
224,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(47:25-47:26),"x"
225,PARAMVARIABLEDECLARATION,"java.lang.integer0",,""
226,DECLAREDREFERENCEEXPRESSION,"nodes",Ex21.java(47:29-47:34),"nodes"
227,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(47:5-47:10),"graph"
228,DECLAREDREFERENCEEXPRESSION,"y",Ex21.java(47:35-47:36),"y"
229,PARAMVARIABLEDECLARATION,"java.lang.integer1",,""
230,STATICCALLEXPRESSION,"sqrt",Ex21.java(45:21-45:107),"Math.sqrt(Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2))"
231,BINARYOPERATOR,"+",Ex21.java(45:31-45:106),"Math.pow((list[y][0]-list[x][0]), 2) + Math.pow((list[y][1]-list[x][1]), 2)"
232,STATICCALLEXPRESSION,"pow",Ex21.java(45:31-45:67),"Math.pow((list[y][0]-list[x][0]), 2)"
233,STATICCALLEXPRESSION,"pow",Ex21.java(45:70-45:106),"Math.pow((list[y][1]-list[x][1]), 2)"
234,DECLAREDREFERENCEEXPRESSION,"list",Ex21.java(45:80-45:84),"list"
235,LITERAL,"",Ex21.java(45:65-45:66),"2"
236,BINARYOPERATOR,"-",Ex21.java(45:41-45:62),"list[y][0]-list[x][0]"
237,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(45:41-45:51),"list[y][0]"
238,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(45:52-45:62),"list[x][0]"
239,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(45:41-45:48),"list[y]"
240,LITERAL,"",Ex21.java(45:49-45:50),"0"
241,DECLAREDREFERENCEEXPRESSION,"list",Ex21.java(45:52-45:56),"list"
242,DECLAREDREFERENCEEXPRESSION,"y",Ex21.java(45:46-45:47),"y"
243,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(45:52-45:59),"list[x]"
244,LITERAL,"",Ex21.java(45:60-45:61),"0"
245,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(45:57-45:58),"x"
246,LITERAL,"",Ex21.java(45:104-45:105),"2"
247,BINARYOPERATOR,"-",Ex21.java(45:80-45:101),"list[y][1]-list[x][1]"
248,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(45:80-45:90),"list[y][1]"
249,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(45:91-45:101),"list[x][1]"
250,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(45:80-45:87),"list[y]"
251,LITERAL,"",Ex21.java(45:88-45:89),"1"
252,DECLAREDREFERENCEEXPRESSION,"list",Ex21.java(45:91-45:95),"list"
253,DECLAREDREFERENCEEXPRESSION,"y",Ex21.java(45:85-45:86),"y"
254,ARRAYSUBSCRIPTIONEXPRESSION,"",Ex21.java(45:91-45:98),"list[x]"
255,LITERAL,"",Ex21.java(45:99-45:100),"1"
256,DECLAREDREFERENCEEXPRESSION,"x",Ex21.java(45:96-45:97),"x"
257,DECLAREDREFERENCEEXPRESSION,"n",Ex21.java(43:27-43:28),"n"
258,DECLAREDREFERENCEEXPRESSION,"n",Ex21.java(41:22-41:23),"n"
259,MEMBEREXPRESSION,"primed",Ex21.java(53:3-53:9),"primed"
260,STATICCALLEXPRESSION,"mst",Ex21.java(53:12-53:27),"Prim.mst(graph)"
261,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(53:21-53:26),"graph"
262,METHODDECLARATION,"mst",,""
263,PARAMVARIABLEDECLARATION,"ex21.undirectedgraph0",,""
264,DECLAREDREFERENCEEXPRESSION,"printf",Ex21.java(65:14-65:20),"printf"
265,MEMBEREXPRESSION,"dou",Ex21.java(65:29-65:32),"dou"
266,MEMBEREXPRESSION,"out",Ex21.java(65:3-65:13),"System.out"
267,LITERAL,"",Ex21.java(65:21-65:27),"""%.2f"""
268,DECLAREDREFERENCEEXPRESSION,"Ex21",Ex21.java(65:29-65:32),"Ex21"
269,FIELDDECLARATION,"this",,""
270,FIELDDECLARATION,"mMin",Ex21.java(465:6-465:35),"mMin = null"
271,FIELDDECLARATION,"mSize",Ex21.java(468:6-468:28),"mSize = 0"
272,METHODDECLARATION,"enqueue",Ex21.java(479:6-495:7),"public Entry<T> enqueue(T value, double priority) {
	        checkPriority(priority);

	        /* Create the entry object, which is a circularly-linked list of length
	         * one.
	         */
	        Entry<T> result = new Entry<T>(value, priority);

	        /* Merge this singleton list with the tree list. */
	        mMin = mergeLists(mMin, result);

	        /* Increase the size of the heap; we just added something. */
	        ++mSize;

	        /* Return the reference to the new element. */
	        return result;
	    }"
273,METHODDECLARATION,"min",Ex21.java(505:6-509:7),"public Entry<T> min() {
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");
	        return mMin;
	    }"
274,METHODDECLARATION,"isEmpty",Ex21.java(516:6-518:7),"public boolean isEmpty() {
	        return mMin == null;
	    }"
275,METHODDECLARATION,"size",Ex21.java(525:6-527:7),"public int size() {
	        return mSize;
	    }"
276,METHODDECLARATION,"merge",Ex21.java(541:6-561:7),"public static <T> FibonacciHeap<T> merge(FibonacciHeap<T> one, FibonacciHeap<T> two) {
	        /* Create a new FibonacciHeap to hold the result. */
	        FibonacciHeap<T> result = new FibonacciHeap<T>();

	        /* Merge the two Fibonacci heap root lists together.  This helper function
	         * also computes the min of the two lists, so we can store the result in
	         * the mMin field of the new heap.
	         */
	        result.mMin = mergeLists(one.mMin, two.mMin);

	        /* The size of the new heap is the sum of the sizes of the input heaps. */
	        result.mSize = one.mSize + two.mSize;

	        /* Clear the old heaps. */
	        one.mSize = two.mSize = 0;
	        one.mMin  = null;
	        two.mMin  = null;

	        /* Return the newly-merged heap. */
	        return result;
	    }"
277,METHODDECLARATION,"dequeueMin",Ex21.java(570:6-708:7),"public Entry<T> dequeueMin() {
	        /* Check for whether we're empty. */
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");

	        /* Otherwise, we're about to lose an element, so decrement the number of
	         * entries in this heap.
	         */
	        --mSize;

	        /* Grab the minimum element so we know what to return. */
	        Entry<T> minElem = mMin;

	        /* Now, we need to get rid of this element from the list of roots.  There
	         * are two cases to consider.  First, if this is the only element in the
	         * list of roots, we set the list of roots to be null by clearing mMin.
	         * Otherwise, if it's not null, then we write the elements next to the
	         * min element around the min element to remove it, then arbitrarily
	         * reassign the min.
	         */
	        if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }

	        /* Next, clear the parent fields of all of the min element's children,
	         * since they're about to become roots.  Because the elements are
	         * stored in a circular list, the traversal is a bit complex.
	         */
	        if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }

	        /* Next, splice the children of the root node into the topmost list, 
	         * then set mMin to point somewhere in that list.
	         */
	        mMin = mergeLists(mMin, minElem.mChild);

	        /* If there are no entries left, we're done. */
	        if (mMin == null) return minElem;

	        /* Next, we need to coalsce all of the roots so that there is only one
	         * tree of each degree.  To track trees of each size, we allocate an
	         * ArrayList where the entry at position i is either null or the 
	         * unique tree of degree i.
	         */
	        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();

	        /* We need to traverse the entire list, but since we're going to be
	         * messing around with it we have to be careful not to break our
	         * traversal order mid-stream.  One major challenge is how to detect
	         * whether we're visiting the same node twice.  To do this, we'll
	         * spent a bit of overhead adding all of the nodes to a list, and
	         * then will visit each element of this list in order.
	         */
	        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();

	        /* To add everything, we'll iterate across the elements until we
	         * find the first element twice.  We check this by looping while the
	         * list is empty or while the current element isn't the first element
	         * of that list.
	         */
	        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);

	        /* Traverse this list and perform the appropriate unioning steps. */
	        for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }
	        return minElem;
	    }"
278,METHODDECLARATION,"decreaseKey",Ex21.java(725:6-732:7),"public void decreaseKey(Entry<T> entry, double newPriority) {
	        checkPriority(newPriority);
	        if (newPriority > entry.mPriority)
	            throw new IllegalArgumentException(""New priority exceeds old."");

	        /* Forward this to a helper function. */
	        decreaseKeyUnchecked(entry, newPriority);
	    }"
279,METHODDECLARATION,"delete",Ex21.java(742:6-750:7),"public void delete(Entry<T> entry) {
	        /* Use decreaseKey to drop the entry's key to -infinity.  This will
	         * guarantee that the node is cut and set to the global minimum.
	         */
	        decreaseKeyUnchecked(entry, Double.NEGATIVE_INFINITY);

	        /* Call dequeueMin to remove it. */
	        dequeueMin();
	    }"
280,METHODDECLARATION,"checkPriority",Ex21.java(759:6-762:7),"private void checkPriority(double priority) {
	        if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + "" is invalid."");
	    }"
281,METHODDECLARATION,"mergeLists",Ex21.java(780:6-834:7),"private static <T> Entry<T> mergeLists(Entry<T> one, Entry<T> two) {
	        /* There are four cases depending on whether the lists are null or not.
	         * We consider each separately.
	         */
	        if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }
	    }"
282,METHODDECLARATION,"decreaseKeyUnchecked",Ex21.java(843:6-861:7),"private void decreaseKeyUnchecked(Entry<T> entry, double priority) {
	        /* First, change the node's priority. */
	        entry.mPriority = priority;

	        /* If the node no longer has a higher priority than its parent, cut it.
	         * Note that this also means that if we try to run a delete operation
	         * that decreases the key to -infinity, it's guaranteed to cut the node
	         * from its parent.
	         */
	        if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);

	        /* If our new value is the new min, mark it as such.  Note that if we
	         * ended up decreasing the key in a way that ties the current minimum
	         * priority, this will change the min accordingly.
	         */
	        if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;
	    }"
283,METHODDECLARATION,"cutNode",Ex21.java(869:6-918:7),"private void cutNode(Entry<T> entry) {
	        /* Begin by clearing the node's mark, since we just cut it. */
	        entry.mIsMarked = false;

	        /* Base case: If the node has no parent, we're done. */
	        if (entry.mParent == null) return;

	        /* Rewire the node's siblings around it, if it has any siblings. */
	        if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }

	        /* If the node is the one identified by its parent as its child,
	         * we need to rewrite that pointer to point to some arbitrary other
	         * child.
	         */
	        if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }

	        /* Decrease the degree of the parent, since it just lost a child. */
	        --entry.mParent.mDegree;

	        /* Splice this tree into the root list by converting it to a singleton
	         * and invoking the merge subroutine.
	         */
	        entry.mPrev = entry.mNext = entry;
	        mMin = mergeLists(mMin, entry);

	        /* Mark the parent and recursively cut it if it's already been
	         * marked.
	         */
	        if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;

	        /* Clear the relocated node's parent; it's now a root. */
	        entry.mParent = null;
	    }"
284,CONSTRUCTORDECLARATION,"Ex21.FibonacciHeap",,""
285,RECORDDECLARATION,"Ex21.FibonacciHeap.Entry",Ex21.java(410:6-462:7),"public static final class Entry<T> {
	        private int     mDegree = 0;       // Number of children
	        private boolean mIsMarked = false; // Whether this node is marked

	        private Entry<T> mNext;   // Next and previous elements in the list
	        private Entry<T> mPrev;

	        private Entry<T> mParent; // Parent in the tree, if any.

	        private Entry<T> mChild;  // Child node, if any.

	        private T      mElem;     // Element being stored here
	        private double mPriority; // Its priority

	        /**
	         * Returns the element represented by this heap entry.
	         *
	         * @return The element represented by this heap entry.
	         */
	        public T getValue() {
	            return mElem;
	        }
	        /**
	         * Sets the element associated with this heap entry.
	         *
	         * @param value The element to associate with this heap entry.
	         */
	        public void setValue(T value) {
	            mElem = value;
	        }

	        /**
	         * Returns the priority of this element.
	         *
	         * @return The priority of this element.
	         */
	        public double getPriority() {
	            return mPriority;
	        }

	        /**
	         * Constructs a new Entry that holds the given element with the indicated 
	         * priority.
	         *
	         * @param elem The element stored in this node.
	         * @param priority The priority of this element.
	         */
	        private Entry(T elem, double priority) {
	            mNext = mPrev = this;
	            mElem = elem;
	            mPriority = priority;
	        }
	    }"
286,VARIABLEDECLARATION,"this",,""
287,COMPOUNDSTATEMENT,"",Ex21.java(570:35-708:7),"{
	        /* Check for whether we're empty. */
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");

	        /* Otherwise, we're about to lose an element, so decrement the number of
	         * entries in this heap.
	         */
	        --mSize;

	        /* Grab the minimum element so we know what to return. */
	        Entry<T> minElem = mMin;

	        /* Now, we need to get rid of this element from the list of roots.  There
	         * are two cases to consider.  First, if this is the only element in the
	         * list of roots, we set the list of roots to be null by clearing mMin.
	         * Otherwise, if it's not null, then we write the elements next to the
	         * min element around the min element to remove it, then arbitrarily
	         * reassign the min.
	         */
	        if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }

	        /* Next, clear the parent fields of all of the min element's children,
	         * since they're about to become roots.  Because the elements are
	         * stored in a circular list, the traversal is a bit complex.
	         */
	        if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }

	        /* Next, splice the children of the root node into the topmost list, 
	         * then set mMin to point somewhere in that list.
	         */
	        mMin = mergeLists(mMin, minElem.mChild);

	        /* If there are no entries left, we're done. */
	        if (mMin == null) return minElem;

	        /* Next, we need to coalsce all of the roots so that there is only one
	         * tree of each degree.  To track trees of each size, we allocate an
	         * ArrayList where the entry at position i is either null or the 
	         * unique tree of degree i.
	         */
	        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();

	        /* We need to traverse the entire list, but since we're going to be
	         * messing around with it we have to be careful not to break our
	         * traversal order mid-stream.  One major challenge is how to detect
	         * whether we're visiting the same node twice.  To do this, we'll
	         * spent a bit of overhead adding all of the nodes to a list, and
	         * then will visit each element of this list in order.
	         */
	        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();

	        /* To add everything, we'll iterate across the elements until we
	         * find the first element twice.  We check this by looping while the
	         * list is empty or while the current element isn't the first element
	         * of that list.
	         */
	        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);

	        /* Traverse this list and perform the appropriate unioning steps. */
	        for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }
	        return minElem;
	    }"
288,CALLEXPRESSION,"isEmpty",Ex21.java(572:14-572:23),"isEmpty()"
289,RETURNSTATEMENT,"",Ex21.java(707:10-707:25),"return minElem;"
290,IFSTATEMENT,"",Ex21.java(572:10-573:65),"if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");"
291,UNARYOPERATOR,"--",Ex21.java(578:10-578:18),"--mSize;"
292,DECLARATIONSTATEMENT,"",Ex21.java(581:10-581:34),"Entry<T> minElem = mMin;"
293,IFSTATEMENT,"",Ex21.java(590:10-597:11),"if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }"
294,IFSTATEMENT,"",Ex21.java(603:10-614:11),"if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }"
295,BINARYOPERATOR,"=",Ex21.java(619:10-619:50),"mMin = mergeLists(mMin, minElem.mChild);"
296,IFSTATEMENT,"",Ex21.java(622:10-622:43),"if (mMin == null) return minElem;"
297,DECLARATIONSTATEMENT,"",Ex21.java(629:10-629:63),"List<Entry<T>> treeTable = new ArrayList<Entry<T>>();"
298,DECLARATIONSTATEMENT,"",Ex21.java(638:10-638:61),"List<Entry<T>> toVisit = new ArrayList<Entry<T>>();"
299,FORSTATEMENT,"",Ex21.java(645:10-646:32),"for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);"
300,FOREACHSTATEMENT,"",Ex21.java(649:10-706:11),"for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }"
301,VARIABLEDECLARATION,"minElem",Ex21.java(581:19-581:33),"minElem = mMin"
302,VARIABLEDECLARATION,"treeTable",Ex21.java(629:25-629:62),"treeTable = new ArrayList<Entry<T>>()"
303,VARIABLEDECLARATION,"toVisit",Ex21.java(638:25-638:60),"toVisit = new ArrayList<Entry<T>>()"
304,UNARYOPERATOR,"throw",Ex21.java(573:14-573:65),"throw new NoSuchElementException(""Heap is empty."");"
305,LITERAL,"",Ex21.java(573:47-573:63),"""Heap is empty."""
306,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(578:12-578:17),"this"
307,METHODDECLARATION,"isEmpty",Ex21.java(508:6-510:7),"public boolean isEmpty() {
	        return mMin == null;
	    }"
308,NEWEXPRESSION,"",Ex21.java(573:20-573:64),"new NoSuchElementException(""Heap is empty."")"
309,CONSTRUCTEXPRESSION,"",Ex21.java(573:20-573:64),"new NoSuchElementException(""Heap is empty."")"
310,DECLAREDREFERENCEEXPRESSION,"mMin",Ex21.java(590:14-590:18),"mMin"
311,MEMBEREXPRESSION,"mSize",Ex21.java(578:12-578:17),"mSize"
312,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(581:29-581:33),"this"
313,MEMBERCALLEXPRESSION,"add",Ex21.java(646:14-646:32),"toVisit.add(curr);"
314,DECLARATIONSTATEMENT,"",Ex21.java(645:15-645:35),"Entry<T> curr = mMin"
315,BINARYOPERATOR,"||",Ex21.java(645:37-645:80),"toVisit.isEmpty() || toVisit.get(0) != curr"
316,BINARYOPERATOR,"=",Ex21.java(645:82-645:99),"curr = curr.mNext"
317,VARIABLEDECLARATION,"curr",Ex21.java(645:24-645:35),"curr = mMin"
318,DECLAREDREFERENCEEXPRESSION,"toVisit",Ex21.java(646:14-646:21),"toVisit"
319,DECLAREDREFERENCEEXPRESSION,"toVisit",Ex21.java(649:30-649:37),"toVisit"
320,MEMBEREXPRESSION,"mMin",Ex21.java(645:31-645:35),"mMin"
321,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(645:31-645:35),"this"
322,MEMBERCALLEXPRESSION,"isEmpty",Ex21.java(645:37-645:54),"toVisit.isEmpty()"
323,BINARYOPERATOR,"!=",Ex21.java(645:58-645:80),"toVisit.get(0) != curr"
324,DECLAREDREFERENCEEXPRESSION,"isEmpty",Ex21.java(645:45-645:52),"isEmpty"
325,DECLAREDREFERENCEEXPRESSION,"toVisit",Ex21.java(645:58-645:65),"toVisit"
326,DECLAREDREFERENCEEXPRESSION,"toVisit",Ex21.java(645:37-645:44),"toVisit"
327,MEMBERCALLEXPRESSION,"get",Ex21.java(645:58-645:72),"toVisit.get(0)"
328,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(645:76-645:80),"curr"
329,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(645:66-645:69),"get"
330,LITERAL,"",Ex21.java(645:70-645:71),"0"
331,DECLAREDREFERENCEEXPRESSION,"add",Ex21.java(646:22-646:25),"add"
332,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(645:82-645:86),"curr"
333,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(646:26-646:30),"curr"
334,MEMBEREXPRESSION,"mNext",Ex21.java(645:89-645:99),"curr.mNext"
335,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(645:89-645:93),"curr"
336,DECLAREDREFERENCEEXPRESSION,"minElem",Ex21.java(707:17-707:24),"minElem"
337,MEMBEREXPRESSION,"mMin",Ex21.java(581:29-581:33),"mMin"
338,BINARYOPERATOR,"==",Ex21.java(622:14-622:26),"mMin == null"
339,RETURNSTATEMENT,"",Ex21.java(622:28-622:43),"return minElem;"
340,DECLAREDREFERENCEEXPRESSION,"minElem",Ex21.java(622:35-622:42),"minElem"
341,CONSTRUCTEXPRESSION,"",Ex21.java(629:37-629:62),"new ArrayList<Entry<T>>()"
342,MEMBEREXPRESSION,"mMin",Ex21.java(622:14-622:18),"mMin"
343,LITERAL,"",Ex21.java(622:22-622:26),"null"
344,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(622:14-622:18),"this"
345,NEWEXPRESSION,"",Ex21.java(629:37-629:62),"new ArrayList<Entry<T>>()"
346,BINARYOPERATOR,"!=",Ex21.java(603:14-603:36),"minElem.mChild != null"
347,COMPOUNDSTATEMENT,"",Ex21.java(603:38-614:11),"{
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }"
348,DECLAREDREFERENCEEXPRESSION,"minElem",Ex21.java(605:30-605:37),"minElem"
349,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(619:10-619:14),"this"
350,DECLARATIONSTATEMENT,"",Ex21.java(605:14-605:45),"Entry<?> curr = minElem.mChild;"
351,DOSTATEMENT,"",Ex21.java(606:14-613:47),"do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);"
352,VARIABLEDECLARATION,"curr",Ex21.java(605:23-605:44),"curr = minElem.mChild"
353,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(607:18-607:22),"curr"
354,MEMBEREXPRESSION,"mChild",Ex21.java(605:30-605:44),"minElem.mChild"
355,BINARYOPERATOR,"!=",Ex21.java(613:23-613:45),"curr != minElem.mChild"
356,COMPOUNDSTATEMENT,"",Ex21.java(606:17-613:15),"{
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            }"
357,BINARYOPERATOR,"=",Ex21.java(607:18-607:38),"curr.mParent = null;"
358,BINARYOPERATOR,"=",Ex21.java(612:18-612:36),"curr = curr.mNext;"
359,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(613:23-613:27),"curr"
360,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(612:18-612:22),"curr"
361,MEMBEREXPRESSION,"mNext",Ex21.java(612:25-612:35),"curr.mNext"
362,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(612:25-612:29),"curr"
363,MEMBEREXPRESSION,"mParent",Ex21.java(607:18-607:30),"curr.mParent"
364,LITERAL,"",Ex21.java(607:33-607:37),"null"
365,MEMBEREXPRESSION,"mChild",Ex21.java(613:31-613:45),"minElem.mChild"
366,DECLAREDREFERENCEEXPRESSION,"minElem",Ex21.java(613:31-613:38),"minElem"
367,MEMBEREXPRESSION,"mChild",Ex21.java(603:14-603:28),"minElem.mChild"
368,LITERAL,"",Ex21.java(603:32-603:36),"null"
369,DECLAREDREFERENCEEXPRESSION,"minElem",Ex21.java(603:14-603:21),"minElem"
370,COMPOUNDSTATEMENT,"",Ex21.java(590:34-592:11),"{ // Case one
	            mMin = null;
	        }"
371,COMPOUNDSTATEMENT,"",Ex21.java(593:15-597:11),"{ // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }"
372,CONSTRUCTEXPRESSION,"",Ex21.java(638:35-638:60),"new ArrayList<Entry<T>>()"
373,MEMBEREXPRESSION,"mMin",Ex21.java(619:10-619:14),"mMin"
374,CALLEXPRESSION,"mergeLists",Ex21.java(619:17-619:49),"mergeLists(mMin, minElem.mChild)"
375,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(619:28-619:32),"this"
376,METHODDECLARATION,"mergeLists",Ex21.java(772:6-826:7),"private static <T> Entry<T> mergeLists(Entry<T> one, Entry<T> two) {
	        /* There are four cases depending on whether the lists are null or not.
	         * We consider each separately.
	         */
	        if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }
	    }"
377,MEMBEREXPRESSION,"mMin",Ex21.java(619:28-619:32),"mMin"
378,MEMBEREXPRESSION,"mChild",Ex21.java(619:34-619:48),"minElem.mChild"
379,DECLAREDREFERENCEEXPRESSION,"minElem",Ex21.java(619:34-619:41),"minElem"
380,PARAMVARIABLEDECLARATION,"two",Ex21.java(772:59-772:71),"Entry<T> two"
381,PARAMVARIABLEDECLARATION,"one",Ex21.java(772:45-772:57),"Entry<T> one"
382,BINARYOPERATOR,"==",Ex21.java(590:14-590:32),"mMin.mNext == mMin"
383,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(591:14-591:18),"this"
384,DECLAREDREFERENCEEXPRESSION,"mMin",Ex21.java(594:14-594:18),"mMin"
385,BINARYOPERATOR,"=",Ex21.java(591:14-591:26),"mMin = null;"
386,MEMBEREXPRESSION,"mMin",Ex21.java(591:14-591:18),"mMin"
387,LITERAL,"",Ex21.java(591:21-591:25),"null"
388,MEMBEREXPRESSION,"mNext",Ex21.java(590:14-590:24),"mMin.mNext"
389,MEMBEREXPRESSION,"mMin",Ex21.java(590:28-590:32),"mMin"
390,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(590:28-590:32),"this"
391,BINARYOPERATOR,"=",Ex21.java(594:14-594:44),"mMin.mPrev.mNext = mMin.mNext;"
392,BINARYOPERATOR,"=",Ex21.java(595:14-595:44),"mMin.mNext.mPrev = mMin.mPrev;"
393,BINARYOPERATOR,"=",Ex21.java(596:14-596:32),"mMin = mMin.mNext;"
394,MEMBEREXPRESSION,"mNext",Ex21.java(594:14-594:30),"mMin.mPrev.mNext"
395,MEMBEREXPRESSION,"mNext",Ex21.java(594:33-594:43),"mMin.mNext"
396,DECLAREDREFERENCEEXPRESSION,"mMin",Ex21.java(595:14-595:18),"mMin"
397,MEMBEREXPRESSION,"mPrev",Ex21.java(594:14-594:24),"mMin.mPrev"
398,DECLAREDREFERENCEEXPRESSION,"mMin",Ex21.java(594:33-594:37),"mMin"
399,MEMBEREXPRESSION,"mMin",Ex21.java(596:14-596:18),"mMin"
400,MEMBEREXPRESSION,"mNext",Ex21.java(596:21-596:31),"mMin.mNext"
401,DECLAREDREFERENCEEXPRESSION,"mMin",Ex21.java(596:21-596:25),"mMin"
402,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(596:14-596:18),"this"
403,MEMBEREXPRESSION,"mPrev",Ex21.java(595:14-595:30),"mMin.mNext.mPrev"
404,MEMBEREXPRESSION,"mPrev",Ex21.java(595:33-595:43),"mMin.mPrev"
405,MEMBEREXPRESSION,"mNext",Ex21.java(595:14-595:24),"mMin.mNext"
406,DECLAREDREFERENCEEXPRESSION,"mMin",Ex21.java(595:33-595:37),"mMin"
407,NEWEXPRESSION,"",Ex21.java(638:35-638:60),"new ArrayList<Entry<T>>()"
408,DECLARATIONSTATEMENT,"",Ex21.java(649:15-649:28),"Entry<T> curr"
409,COMPOUNDSTATEMENT,"",Ex21.java(649:39-706:11),"{
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }"
410,VARIABLEDECLARATION,"curr",Ex21.java(649:24-649:28),"curr"
411,LITERAL,"",Ex21.java(651:21-651:25),"true"
412,UNINITIALIZEDVALUE,"Uninitialized Value",,""
413,WHILESTATEMENT,"",Ex21.java(651:14-697:15),"while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }"
414,IFSTATEMENT,"",Ex21.java(705:14-705:64),"if (curr.mPriority <= mMin.mPriority) mMin = curr;"
415,BINARYOPERATOR,"=",Ex21.java(705:52-705:64),"mMin = curr;"
416,BINARYOPERATOR,"<=",Ex21.java(705:18-705:50),"curr.mPriority <= mMin.mPriority"
417,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(705:52-705:56),"this"
418,MEMBEREXPRESSION,"mPriority",Ex21.java(705:18-705:32),"curr.mPriority"
419,MEMBEREXPRESSION,"mPriority",Ex21.java(705:36-705:50),"mMin.mPriority"
420,DECLAREDREFERENCEEXPRESSION,"mMin",Ex21.java(705:36-705:40),"mMin"
421,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(705:18-705:22),"curr"
422,BREAKSTATEMENT,"",Ex21.java(663:22-663:28),"break;"
423,MEMBEREXPRESSION,"mMin",Ex21.java(705:52-705:56),"mMin"
424,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(705:59-705:63),"curr"
425,COMPOUNDSTATEMENT,"",Ex21.java(651:27-697:15),"{
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }"
426,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(655:25-655:29),"curr"
427,WHILESTATEMENT,"",Ex21.java(655:18-656:42),"while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);"
428,IFSTATEMENT,"",Ex21.java(661:18-664:19),"if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }"
429,DECLARATIONSTATEMENT,"",Ex21.java(667:18-667:63),"Entry<T> other = treeTable.get(curr.mDegree);"
430,MEMBERCALLEXPRESSION,"set",Ex21.java(668:18-668:52),"treeTable.set(curr.mDegree, null);"
431,DECLARATIONSTATEMENT,"",Ex21.java(673:18-673:82),"Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;"
432,DECLARATIONSTATEMENT,"",Ex21.java(674:18-674:83),"Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;"
433,BINARYOPERATOR,"=",Ex21.java(679:18-679:46),"max.mNext.mPrev = max.mPrev;"
434,BINARYOPERATOR,"=",Ex21.java(680:18-680:46),"max.mPrev.mNext = max.mNext;"
435,BINARYOPERATOR,"=",Ex21.java(683:18-683:46),"max.mNext = max.mPrev = max;"
436,BINARYOPERATOR,"=",Ex21.java(684:18-684:59),"min.mChild = mergeLists(min.mChild, max);"
437,BINARYOPERATOR,"=",Ex21.java(687:18-687:36),"max.mParent = min;"
438,BINARYOPERATOR,"=",Ex21.java(690:18-690:40),"max.mIsMarked = false;"
439,UNARYOPERATOR,"++",Ex21.java(693:18-693:32),"++min.mDegree;"
440,BINARYOPERATOR,"=",Ex21.java(696:18-696:29),"curr = min;"
441,VARIABLEDECLARATION,"other",Ex21.java(667:27-667:62),"other = treeTable.get(curr.mDegree)"
442,VARIABLEDECLARATION,"min",Ex21.java(673:27-673:81),"min = (other.mPriority < curr.mPriority)? other : curr"
443,VARIABLEDECLARATION,"max",Ex21.java(674:27-674:82),"max = (other.mPriority < curr.mPriority)? curr  : other"
444,DECLAREDREFERENCEEXPRESSION,"treeTable",Ex21.java(668:18-668:27),"treeTable"
445,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(679:18-679:21),"max"
446,BINARYOPERATOR,">=",Ex21.java(655:25-655:57),"curr.mDegree >= treeTable.size()"
447,MEMBERCALLEXPRESSION,"add",Ex21.java(656:22-656:42),"treeTable.add(null);"
448,DECLAREDREFERENCEEXPRESSION,"treeTable",Ex21.java(656:22-656:31),"treeTable"
449,DECLAREDREFERENCEEXPRESSION,"treeTable",Ex21.java(661:22-661:31),"treeTable"
450,MEMBEREXPRESSION,"mDegree",Ex21.java(655:25-655:37),"curr.mDegree"
451,MEMBERCALLEXPRESSION,"size",Ex21.java(655:41-655:57),"treeTable.size()"
452,DECLAREDREFERENCEEXPRESSION,"treeTable",Ex21.java(655:41-655:50),"treeTable"
453,DECLAREDREFERENCEEXPRESSION,"size",Ex21.java(655:51-655:55),"size"
454,DECLAREDREFERENCEEXPRESSION,"add",Ex21.java(656:32-656:35),"add"
455,LITERAL,"",Ex21.java(656:36-656:40),"null"
456,MEMBEREXPRESSION,"mChild",Ex21.java(684:18-684:28),"min.mChild"
457,CALLEXPRESSION,"mergeLists",Ex21.java(684:31-684:58),"mergeLists(min.mChild, max)"
458,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(687:18-687:21),"max"
459,DECLAREDREFERENCEEXPRESSION,"min",Ex21.java(684:18-684:21),"min"
460,DECLAREDREFERENCEEXPRESSION,"min",Ex21.java(684:42-684:45),"min"
461,MEMBEREXPRESSION,"mChild",Ex21.java(684:42-684:52),"min.mChild"
462,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(684:54-684:57),"max"
463,MEMBERCALLEXPRESSION,"get",Ex21.java(667:35-667:62),"treeTable.get(curr.mDegree)"
464,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(667:45-667:48),"get"
465,MEMBEREXPRESSION,"mDegree",Ex21.java(667:49-667:61),"curr.mDegree"
466,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(667:49-667:53),"curr"
467,DECLAREDREFERENCEEXPRESSION,"treeTable",Ex21.java(667:35-667:44),"treeTable"
468,CONDITIONALEXPRESSION,"",Ex21.java(674:33-674:82),"(other.mPriority < curr.mPriority)? curr  : other"
469,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(674:69-674:73),"curr"
470,DECLAREDREFERENCEEXPRESSION,"other",Ex21.java(674:77-674:82),"other"
471,BINARYOPERATOR,"<",Ex21.java(674:34-674:66),"other.mPriority < curr.mPriority"
472,MEMBEREXPRESSION,"mPriority",Ex21.java(674:34-674:49),"other.mPriority"
473,MEMBEREXPRESSION,"mPriority",Ex21.java(674:52-674:66),"curr.mPriority"
474,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(674:52-674:56),"curr"
475,DECLAREDREFERENCEEXPRESSION,"other",Ex21.java(674:34-674:39),"other"
476,MEMBEREXPRESSION,"mNext",Ex21.java(680:18-680:33),"max.mPrev.mNext"
477,MEMBEREXPRESSION,"mNext",Ex21.java(680:36-680:45),"max.mNext"
478,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(683:18-683:21),"max"
479,MEMBEREXPRESSION,"mPrev",Ex21.java(680:18-680:27),"max.mPrev"
480,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(680:36-680:39),"max"
481,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(680:18-680:21),"max"
482,MEMBEREXPRESSION,"mPrev",Ex21.java(679:18-679:33),"max.mNext.mPrev"
483,MEMBEREXPRESSION,"mPrev",Ex21.java(679:36-679:45),"max.mPrev"
484,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(679:36-679:39),"max"
485,MEMBEREXPRESSION,"mNext",Ex21.java(679:18-679:27),"max.mNext"
486,DECLAREDREFERENCEEXPRESSION,"set",Ex21.java(668:28-668:31),"set"
487,DECLAREDREFERENCEEXPRESSION,"other",Ex21.java(673:34-673:39),"other"
488,LITERAL,"",Ex21.java(668:46-668:50),"null"
489,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(668:32-668:36),"curr"
490,MEMBEREXPRESSION,"mDegree",Ex21.java(668:32-668:44),"curr.mDegree"
491,BINARYOPERATOR,"==",Ex21.java(661:22-661:57),"treeTable.get(curr.mDegree) == null"
492,COMPOUNDSTATEMENT,"",Ex21.java(661:59-664:19),"{
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }"
493,DECLAREDREFERENCEEXPRESSION,"treeTable",Ex21.java(662:22-662:31),"treeTable"
494,MEMBERCALLEXPRESSION,"get",Ex21.java(661:22-661:49),"treeTable.get(curr.mDegree)"
495,LITERAL,"",Ex21.java(661:53-661:57),"null"
496,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(661:32-661:35),"get"
497,MEMBEREXPRESSION,"mDegree",Ex21.java(661:36-661:48),"curr.mDegree"
498,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(661:36-661:40),"curr"
499,MEMBERCALLEXPRESSION,"set",Ex21.java(662:22-662:56),"treeTable.set(curr.mDegree, curr);"
500,DECLAREDREFERENCEEXPRESSION,"set",Ex21.java(662:32-662:35),"set"
501,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(662:50-662:54),"curr"
502,MEMBEREXPRESSION,"mDegree",Ex21.java(662:36-662:48),"curr.mDegree"
503,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(662:36-662:40),"curr"
504,MEMBEREXPRESSION,"mNext",Ex21.java(683:18-683:27),"max.mNext"
505,BINARYOPERATOR,"=",Ex21.java(683:30-683:45),"max.mPrev = max"
506,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(683:30-683:33),"max"
507,MEMBEREXPRESSION,"mPrev",Ex21.java(683:30-683:39),"max.mPrev"
508,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(683:42-683:45),"max"
509,MEMBEREXPRESSION,"mIsMarked",Ex21.java(690:18-690:31),"max.mIsMarked"
510,LITERAL,"",Ex21.java(690:34-690:39),"false"
511,DECLAREDREFERENCEEXPRESSION,"min",Ex21.java(693:20-693:23),"min"
512,DECLAREDREFERENCEEXPRESSION,"max",Ex21.java(690:18-690:21),"max"
513,MEMBEREXPRESSION,"mParent",Ex21.java(687:18-687:29),"max.mParent"
514,DECLAREDREFERENCEEXPRESSION,"min",Ex21.java(687:32-687:35),"min"
515,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(696:18-696:22),"curr"
516,DECLAREDREFERENCEEXPRESSION,"min",Ex21.java(696:25-696:28),"min"
517,CONDITIONALEXPRESSION,"",Ex21.java(673:33-673:81),"(other.mPriority < curr.mPriority)? other : curr"
518,DECLAREDREFERENCEEXPRESSION,"other",Ex21.java(673:69-673:74),"other"
519,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(673:77-673:81),"curr"
520,BINARYOPERATOR,"<",Ex21.java(673:34-673:66),"other.mPriority < curr.mPriority"
521,MEMBEREXPRESSION,"mPriority",Ex21.java(673:34-673:49),"other.mPriority"
522,MEMBEREXPRESSION,"mPriority",Ex21.java(673:52-673:66),"curr.mPriority"
523,DECLAREDREFERENCEEXPRESSION,"curr",Ex21.java(673:52-673:56),"curr"
524,MEMBEREXPRESSION,"mDegree",Ex21.java(693:20-693:31),"min.mDegree"
525,VARIABLEDECLARATION,"this",,""
526,COMPOUNDSTATEMENT,"",Ex21.java(479:56-495:7),"{
	        checkPriority(priority);

	        /* Create the entry object, which is a circularly-linked list of length
	         * one.
	         */
	        Entry<T> result = new Entry<T>(value, priority);

	        /* Merge this singleton list with the tree list. */
	        mMin = mergeLists(mMin, result);

	        /* Increase the size of the heap; we just added something. */
	        ++mSize;

	        /* Return the reference to the new element. */
	        return result;
	    }"
527,PARAMVARIABLEDECLARATION,"value",Ex21.java(479:30-479:37),"T value"
528,PARAMVARIABLEDECLARATION,"priority",Ex21.java(479:39-479:54),"double priority"
529,DECLAREDREFERENCEEXPRESSION,"priority",Ex21.java(480:24-480:32),"priority"
530,RETURNSTATEMENT,"",Ex21.java(494:10-494:24),"return result;"
531,CALLEXPRESSION,"checkPriority",Ex21.java(480:10-480:34),"checkPriority(priority);"
532,DECLARATIONSTATEMENT,"",Ex21.java(485:10-485:58),"Entry<T> result = new Entry<T>(value, priority);"
533,BINARYOPERATOR,"=",Ex21.java(488:10-488:42),"mMin = mergeLists(mMin, result);"
534,UNARYOPERATOR,"++",Ex21.java(491:10-491:18),"++mSize;"
535,VARIABLEDECLARATION,"result",Ex21.java(485:19-485:57),"result = new Entry<T>(value, priority)"
536,METHODDECLARATION,"checkPriority",Ex21.java(751:6-754:7),"private void checkPriority(double priority) {
	        if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + "" is invalid."");
	    }"
537,DECLAREDREFERENCEEXPRESSION,"value",Ex21.java(485:41-485:46),"value"
538,PARAMVARIABLEDECLARATION,"priority",Ex21.java(751:33-751:48),"double priority"
539,MEMBEREXPRESSION,"mMin",Ex21.java(488:10-488:14),"mMin"
540,CALLEXPRESSION,"mergeLists",Ex21.java(488:17-488:41),"mergeLists(mMin, result)"
541,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(491:12-491:17),"this"
542,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(488:10-488:14),"this"
543,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(488:28-488:32),"this"
544,MEMBEREXPRESSION,"mMin",Ex21.java(488:28-488:32),"mMin"
545,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(488:34-488:40),"result"
546,NEWEXPRESSION,"",Ex21.java(485:28-485:57),"new Entry<T>(value, priority)"
547,CONSTRUCTEXPRESSION,"",Ex21.java(485:28-485:57),"new Entry<T>(value, priority)"
548,CONSTRUCTORDECLARATION,"Ex21.FibonacciHeap.Entry",,""
549,DECLAREDREFERENCEEXPRESSION,"priority",Ex21.java(485:48-485:56),"priority"
550,PARAMVARIABLEDECLARATION,"double1",,""
551,PARAMVARIABLEDECLARATION,"t0",,""
552,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(494:17-494:23),"result"
553,MEMBEREXPRESSION,"mSize",Ex21.java(491:12-491:17),"mSize"
554,VARIABLEDECLARATION,"this",,""
555,COMPOUNDSTATEMENT,"",Ex21.java(525:24-527:7),"{
	        return mSize;
	    }"
556,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(526:17-526:22),"this"
557,RETURNSTATEMENT,"",Ex21.java(526:10-526:23),"return mSize;"
558,MEMBEREXPRESSION,"mSize",Ex21.java(526:17-526:22),"mSize"
559,VARIABLEDECLARATION,"this",,""
560,COMPOUNDSTATEMENT,"",Ex21.java(843:73-861:7),"{
	        /* First, change the node's priority. */
	        entry.mPriority = priority;

	        /* If the node no longer has a higher priority than its parent, cut it.
	         * Note that this also means that if we try to run a delete operation
	         * that decreases the key to -infinity, it's guaranteed to cut the node
	         * from its parent.
	         */
	        if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);

	        /* If our new value is the new min, mark it as such.  Note that if we
	         * ended up decreasing the key in a way that ties the current minimum
	         * priority, this will change the min accordingly.
	         */
	        if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;
	    }"
561,PARAMVARIABLEDECLARATION,"entry",Ex21.java(843:40-843:54),"Entry<T> entry"
562,PARAMVARIABLEDECLARATION,"priority",Ex21.java(843:56-843:71),"double priority"
563,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(845:10-845:15),"entry"
564,RETURNSTATEMENT,"",,""
565,BINARYOPERATOR,"=",Ex21.java(845:10-845:37),"entry.mPriority = priority;"
566,IFSTATEMENT,"",Ex21.java(852:10-853:29),"if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);"
567,IFSTATEMENT,"",Ex21.java(859:10-860:27),"if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;"
568,MEMBEREXPRESSION,"mPriority",Ex21.java(845:10-845:25),"entry.mPriority"
569,DECLAREDREFERENCEEXPRESSION,"priority",Ex21.java(845:28-845:36),"priority"
570,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(852:14-852:19),"entry"
571,BINARYOPERATOR,"<=",Ex21.java(859:14-859:47),"entry.mPriority <= mMin.mPriority"
572,BINARYOPERATOR,"=",Ex21.java(860:14-860:27),"mMin = entry;"
573,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(860:14-860:18),"this"
574,MEMBEREXPRESSION,"mMin",Ex21.java(860:14-860:18),"mMin"
575,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(860:21-860:26),"entry"
576,MEMBEREXPRESSION,"mPriority",Ex21.java(859:14-859:29),"entry.mPriority"
577,MEMBEREXPRESSION,"mPriority",Ex21.java(859:33-859:47),"mMin.mPriority"
578,DECLAREDREFERENCEEXPRESSION,"mMin",Ex21.java(859:33-859:37),"mMin"
579,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(859:14-859:19),"entry"
580,CALLEXPRESSION,"cutNode",Ex21.java(853:14-853:29),"cutNode(entry);"
581,BINARYOPERATOR,"&&",Ex21.java(852:14-852:81),"entry.mParent != null && entry.mPriority <= entry.mParent.mPriority"
582,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(853:22-853:27),"entry"
583,METHODDECLARATION,"cutNode",Ex21.java(861:6-910:7),"private void cutNode(Entry<T> entry) {
	        /* Begin by clearing the node's mark, since we just cut it. */
	        entry.mIsMarked = false;

	        /* Base case: If the node has no parent, we're done. */
	        if (entry.mParent == null) return;

	        /* Rewire the node's siblings around it, if it has any siblings. */
	        if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }

	        /* If the node is the one identified by its parent as its child,
	         * we need to rewrite that pointer to point to some arbitrary other
	         * child.
	         */
	        if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }

	        /* Decrease the degree of the parent, since it just lost a child. */
	        --entry.mParent.mDegree;

	        /* Splice this tree into the root list by converting it to a singleton
	         * and invoking the merge subroutine.
	         */
	        entry.mPrev = entry.mNext = entry;
	        mMin = mergeLists(mMin, entry);

	        /* Mark the parent and recursively cut it if it's already been
	         * marked.
	         */
	        if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;

	        /* Clear the relocated node's parent; it's now a root. */
	        entry.mParent = null;
	    }"
584,PARAMVARIABLEDECLARATION,"entry",Ex21.java(861:27-861:41),"Entry<T> entry"
585,BINARYOPERATOR,"!=",Ex21.java(852:14-852:35),"entry.mParent != null"
586,BINARYOPERATOR,"<=",Ex21.java(852:39-852:81),"entry.mPriority <= entry.mParent.mPriority"
587,MEMBEREXPRESSION,"mParent",Ex21.java(852:14-852:27),"entry.mParent"
588,LITERAL,"",Ex21.java(852:31-852:35),"null"
589,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(852:39-852:44),"entry"
590,MEMBEREXPRESSION,"mPriority",Ex21.java(852:39-852:54),"entry.mPriority"
591,MEMBEREXPRESSION,"mPriority",Ex21.java(852:58-852:81),"entry.mParent.mPriority"
592,MEMBEREXPRESSION,"mParent",Ex21.java(852:58-852:71),"entry.mParent"
593,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(852:58-852:63),"entry"
594,VARIABLEDECLARATION,"this",,""
595,COMPOUNDSTATEMENT,"",Ex21.java(541:91-561:7),"{
	        /* Create a new FibonacciHeap to hold the result. */
	        FibonacciHeap<T> result = new FibonacciHeap<T>();

	        /* Merge the two Fibonacci heap root lists together.  This helper function
	         * also computes the min of the two lists, so we can store the result in
	         * the mMin field of the new heap.
	         */
	        result.mMin = mergeLists(one.mMin, two.mMin);

	        /* The size of the new heap is the sum of the sizes of the input heaps. */
	        result.mSize = one.mSize + two.mSize;

	        /* Clear the old heaps. */
	        one.mSize = two.mSize = 0;
	        one.mMin  = null;
	        two.mMin  = null;

	        /* Return the newly-merged heap. */
	        return result;
	    }"
596,PARAMVARIABLEDECLARATION,"one",Ex21.java(541:47-541:67),"FibonacciHeap<T> one"
597,PARAMVARIABLEDECLARATION,"two",Ex21.java(541:69-541:89),"FibonacciHeap<T> two"
598,CONSTRUCTEXPRESSION,"",Ex21.java(543:36-543:58),"new FibonacciHeap<T>()"
599,RETURNSTATEMENT,"",Ex21.java(560:10-560:24),"return result;"
600,DECLARATIONSTATEMENT,"",Ex21.java(543:10-543:59),"FibonacciHeap<T> result = new FibonacciHeap<T>();"
601,BINARYOPERATOR,"=",Ex21.java(549:10-549:55),"result.mMin = mergeLists(one.mMin, two.mMin);"
602,BINARYOPERATOR,"=",Ex21.java(552:10-552:47),"result.mSize = one.mSize + two.mSize;"
603,BINARYOPERATOR,"=",Ex21.java(555:10-555:36),"one.mSize = two.mSize = 0;"
604,BINARYOPERATOR,"=",Ex21.java(556:10-556:27),"one.mMin  = null;"
605,BINARYOPERATOR,"=",Ex21.java(557:10-557:27),"two.mMin  = null;"
606,VARIABLEDECLARATION,"result",Ex21.java(543:27-543:58),"result = new FibonacciHeap<T>()"
607,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(549:10-549:16),"result"
608,MEMBEREXPRESSION,"mMin",Ex21.java(549:10-549:21),"result.mMin"
609,CALLEXPRESSION,"mergeLists",Ex21.java(549:24-549:54),"mergeLists(one.mMin, two.mMin)"
610,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(552:10-552:16),"result"
611,MEMBEREXPRESSION,"mMin",Ex21.java(549:35-549:43),"one.mMin"
612,MEMBEREXPRESSION,"mMin",Ex21.java(549:45-549:53),"two.mMin"
613,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(549:45-549:48),"two"
614,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(549:35-549:38),"one"
615,NEWEXPRESSION,"",Ex21.java(543:36-543:58),"new FibonacciHeap<T>()"
616,CONSTRUCTORDECLARATION,"Ex21.FibonacciHeap",,""
617,MEMBEREXPRESSION,"mMin",Ex21.java(556:10-556:18),"one.mMin"
618,LITERAL,"",Ex21.java(556:22-556:26),"null"
619,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(557:10-557:13),"two"
620,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(556:10-556:13),"one"
621,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(560:17-560:23),"result"
622,MEMBEREXPRESSION,"mSize",Ex21.java(552:10-552:22),"result.mSize"
623,BINARYOPERATOR,"+",Ex21.java(552:25-552:46),"one.mSize + two.mSize"
624,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(555:10-555:13),"one"
625,MEMBEREXPRESSION,"mSize",Ex21.java(552:25-552:34),"one.mSize"
626,MEMBEREXPRESSION,"mSize",Ex21.java(552:37-552:46),"two.mSize"
627,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(552:37-552:40),"two"
628,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(552:25-552:28),"one"
629,MEMBEREXPRESSION,"mSize",Ex21.java(555:10-555:19),"one.mSize"
630,BINARYOPERATOR,"=",Ex21.java(555:22-555:35),"two.mSize = 0"
631,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(555:22-555:25),"two"
632,MEMBEREXPRESSION,"mSize",Ex21.java(555:22-555:31),"two.mSize"
633,LITERAL,"",Ex21.java(555:34-555:35),"0"
634,MEMBEREXPRESSION,"mMin",Ex21.java(557:10-557:18),"two.mMin"
635,LITERAL,"",Ex21.java(557:22-557:26),"null"
636,LITERAL,"",Ex21.java(465:30-465:34),"null"
637,VARIABLEDECLARATION,"this",,""
638,COMPOUNDSTATEMENT,"",Ex21.java(516:31-518:7),"{
	        return mMin == null;
	    }"
639,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(517:17-517:21),"this"
640,RETURNSTATEMENT,"",Ex21.java(517:10-517:30),"return mMin == null;"
641,BINARYOPERATOR,"==",Ex21.java(517:17-517:29),"mMin == null"
642,MEMBEREXPRESSION,"mMin",Ex21.java(517:17-517:21),"mMin"
643,LITERAL,"",Ex21.java(517:25-517:29),"null"
644,VARIABLEDECLARATION,"this",,""
645,COMPOUNDSTATEMENT,"",Ex21.java(742:41-750:7),"{
	        /* Use decreaseKey to drop the entry's key to -infinity.  This will
	         * guarantee that the node is cut and set to the global minimum.
	         */
	        decreaseKeyUnchecked(entry, Double.NEGATIVE_INFINITY);

	        /* Call dequeueMin to remove it. */
	        dequeueMin();
	    }"
646,PARAMVARIABLEDECLARATION,"entry",Ex21.java(742:25-742:39),"Entry<T> entry"
647,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(746:31-746:36),"entry"
648,RETURNSTATEMENT,"",,""
649,CALLEXPRESSION,"decreaseKeyUnchecked",Ex21.java(746:10-746:64),"decreaseKeyUnchecked(entry, Double.NEGATIVE_INFINITY);"
650,CALLEXPRESSION,"dequeueMin",Ex21.java(749:10-749:23),"dequeueMin();"
651,METHODDECLARATION,"dequeueMin",Ex21.java(562:6-700:7),"public Entry<T> dequeueMin() {
	        /* Check for whether we're empty. */
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");

	        /* Otherwise, we're about to lose an element, so decrement the number of
	         * entries in this heap.
	         */
	        --mSize;

	        /* Grab the minimum element so we know what to return. */
	        Entry<T> minElem = mMin;

	        /* Now, we need to get rid of this element from the list of roots.  There
	         * are two cases to consider.  First, if this is the only element in the
	         * list of roots, we set the list of roots to be null by clearing mMin.
	         * Otherwise, if it's not null, then we write the elements next to the
	         * min element around the min element to remove it, then arbitrarily
	         * reassign the min.
	         */
	        if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }

	        /* Next, clear the parent fields of all of the min element's children,
	         * since they're about to become roots.  Because the elements are
	         * stored in a circular list, the traversal is a bit complex.
	         */
	        if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }

	        /* Next, splice the children of the root node into the topmost list, 
	         * then set mMin to point somewhere in that list.
	         */
	        mMin = mergeLists(mMin, minElem.mChild);

	        /* If there are no entries left, we're done. */
	        if (mMin == null) return minElem;

	        /* Next, we need to coalsce all of the roots so that there is only one
	         * tree of each degree.  To track trees of each size, we allocate an
	         * ArrayList where the entry at position i is either null or the 
	         * unique tree of degree i.
	         */
	        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();

	        /* We need to traverse the entire list, but since we're going to be
	         * messing around with it we have to be careful not to break our
	         * traversal order mid-stream.  One major challenge is how to detect
	         * whether we're visiting the same node twice.  To do this, we'll
	         * spent a bit of overhead adding all of the nodes to a list, and
	         * then will visit each element of this list in order.
	         */
	        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();

	        /* To add everything, we'll iterate across the elements until we
	         * find the first element twice.  We check this by looping while the
	         * list is empty or while the current element isn't the first element
	         * of that list.
	         */
	        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);

	        /* Traverse this list and perform the appropriate unioning steps. */
	        for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }
	        return minElem;
	    }"
652,METHODDECLARATION,"decreaseKeyUnchecked",Ex21.java(835:6-853:7),"private void decreaseKeyUnchecked(Entry<T> entry, double priority) {
	        /* First, change the node's priority. */
	        entry.mPriority = priority;

	        /* If the node no longer has a higher priority than its parent, cut it.
	         * Note that this also means that if we try to run a delete operation
	         * that decreases the key to -infinity, it's guaranteed to cut the node
	         * from its parent.
	         */
	        if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);

	        /* If our new value is the new min, mark it as such.  Note that if we
	         * ended up decreasing the key in a way that ties the current minimum
	         * priority, this will change the min accordingly.
	         */
	        if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;
	    }"
653,MEMBEREXPRESSION,"NEGATIVE_INFINITY",Ex21.java(746:38-746:62),"Double.NEGATIVE_INFINITY"
654,PARAMVARIABLEDECLARATION,"entry",Ex21.java(835:40-835:54),"Entry<T> entry"
655,DECLAREDREFERENCEEXPRESSION,"Double",Ex21.java(746:38-746:44),"Double"
656,PARAMVARIABLEDECLARATION,"priority",Ex21.java(835:56-835:71),"double priority"
657,VARIABLEDECLARATION,"this",,""
658,COMPOUNDSTATEMENT,"",Ex21.java(869:43-918:7),"{
	        /* Begin by clearing the node's mark, since we just cut it. */
	        entry.mIsMarked = false;

	        /* Base case: If the node has no parent, we're done. */
	        if (entry.mParent == null) return;

	        /* Rewire the node's siblings around it, if it has any siblings. */
	        if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }

	        /* If the node is the one identified by its parent as its child,
	         * we need to rewrite that pointer to point to some arbitrary other
	         * child.
	         */
	        if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }

	        /* Decrease the degree of the parent, since it just lost a child. */
	        --entry.mParent.mDegree;

	        /* Splice this tree into the root list by converting it to a singleton
	         * and invoking the merge subroutine.
	         */
	        entry.mPrev = entry.mNext = entry;
	        mMin = mergeLists(mMin, entry);

	        /* Mark the parent and recursively cut it if it's already been
	         * marked.
	         */
	        if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;

	        /* Clear the relocated node's parent; it's now a root. */
	        entry.mParent = null;
	    }"
659,PARAMVARIABLEDECLARATION,"entry",Ex21.java(869:27-869:41),"Entry<T> entry"
660,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(871:10-871:15),"entry"
661,RETURNSTATEMENT,"",,""
662,BINARYOPERATOR,"=",Ex21.java(871:10-871:34),"entry.mIsMarked = false;"
663,IFSTATEMENT,"",Ex21.java(874:10-874:44),"if (entry.mParent == null) return;"
664,IFSTATEMENT,"",Ex21.java(877:10-880:11),"if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }"
665,IFSTATEMENT,"",Ex21.java(886:10-897:11),"if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }"
666,UNARYOPERATOR,"--",Ex21.java(900:10-900:34),"--entry.mParent.mDegree;"
667,BINARYOPERATOR,"=",Ex21.java(905:10-905:44),"entry.mPrev = entry.mNext = entry;"
668,BINARYOPERATOR,"=",Ex21.java(906:10-906:41),"mMin = mergeLists(mMin, entry);"
669,IFSTATEMENT,"",Ex21.java(911:10-914:45),"if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;"
670,BINARYOPERATOR,"=",Ex21.java(917:10-917:31),"entry.mParent = null;"
671,MEMBEREXPRESSION,"mDegree",Ex21.java(900:12-900:33),"entry.mParent.mDegree"
672,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(905:10-905:15),"entry"
673,MEMBEREXPRESSION,"mParent",Ex21.java(900:12-900:25),"entry.mParent"
674,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(900:12-900:17),"entry"
675,COMPOUNDSTATEMENT,"",Ex21.java(886:45-897:11),"{
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }"
676,BINARYOPERATOR,"!=",Ex21.java(877:14-877:34),"entry.mNext != entry"
677,COMPOUNDSTATEMENT,"",Ex21.java(877:36-880:11),"{ // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }"
678,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(878:14-878:19),"entry"
679,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(886:14-886:19),"entry"
680,MEMBEREXPRESSION,"mNext",Ex21.java(877:14-877:25),"entry.mNext"
681,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(877:29-877:34),"entry"
682,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(877:14-877:19),"entry"
683,BINARYOPERATOR,"=",Ex21.java(878:14-878:46),"entry.mNext.mPrev = entry.mPrev;"
684,BINARYOPERATOR,"=",Ex21.java(879:14-879:46),"entry.mPrev.mNext = entry.mNext;"
685,MEMBEREXPRESSION,"mNext",Ex21.java(879:14-879:31),"entry.mPrev.mNext"
686,MEMBEREXPRESSION,"mNext",Ex21.java(879:34-879:45),"entry.mNext"
687,MEMBEREXPRESSION,"mPrev",Ex21.java(879:14-879:25),"entry.mPrev"
688,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(879:34-879:39),"entry"
689,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(879:14-879:19),"entry"
690,MEMBEREXPRESSION,"mPrev",Ex21.java(878:14-878:31),"entry.mNext.mPrev"
691,MEMBEREXPRESSION,"mPrev",Ex21.java(878:34-878:45),"entry.mPrev"
692,MEMBEREXPRESSION,"mNext",Ex21.java(878:14-878:25),"entry.mNext"
693,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(878:34-878:39),"entry"
694,MEMBEREXPRESSION,"mPrev",Ex21.java(905:10-905:21),"entry.mPrev"
695,BINARYOPERATOR,"=",Ex21.java(905:24-905:43),"entry.mNext = entry"
696,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(906:10-906:14),"this"
697,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(905:24-905:29),"entry"
698,MEMBEREXPRESSION,"mNext",Ex21.java(905:24-905:35),"entry.mNext"
699,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(905:38-905:43),"entry"
700,MEMBEREXPRESSION,"mParent",Ex21.java(917:10-917:23),"entry.mParent"
701,LITERAL,"",Ex21.java(917:26-917:30),"null"
702,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(917:10-917:15),"entry"
703,CALLEXPRESSION,"cutNode",Ex21.java(912:14-912:37),"cutNode(entry.mParent);"
704,BINARYOPERATOR,"=",Ex21.java(914:14-914:45),"entry.mParent.mIsMarked = true;"
705,MEMBEREXPRESSION,"mIsMarked",Ex21.java(911:14-911:37),"entry.mParent.mIsMarked"
706,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(912:22-912:27),"entry"
707,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(914:14-914:19),"entry"
708,MEMBEREXPRESSION,"mParent",Ex21.java(912:22-912:35),"entry.mParent"
709,MEMBEREXPRESSION,"mIsMarked",Ex21.java(914:14-914:37),"entry.mParent.mIsMarked"
710,LITERAL,"",Ex21.java(914:40-914:44),"true"
711,MEMBEREXPRESSION,"mParent",Ex21.java(914:14-914:27),"entry.mParent"
712,MEMBEREXPRESSION,"mParent",Ex21.java(911:14-911:27),"entry.mParent"
713,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(911:14-911:19),"entry"
714,MEMBEREXPRESSION,"mMin",Ex21.java(906:10-906:14),"mMin"
715,CALLEXPRESSION,"mergeLists",Ex21.java(906:17-906:40),"mergeLists(mMin, entry)"
716,MEMBEREXPRESSION,"mMin",Ex21.java(906:28-906:32),"mMin"
717,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(906:34-906:39),"entry"
718,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(906:28-906:32),"this"
719,MEMBEREXPRESSION,"mIsMarked",Ex21.java(871:10-871:25),"entry.mIsMarked"
720,LITERAL,"",Ex21.java(871:28-871:33),"false"
721,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(874:14-874:19),"entry"
722,BINARYOPERATOR,"==",Ex21.java(874:14-874:35),"entry.mParent == null"
723,RETURNSTATEMENT,"",Ex21.java(874:37-874:44),"return;"
724,MEMBEREXPRESSION,"mParent",Ex21.java(874:14-874:27),"entry.mParent"
725,LITERAL,"",Ex21.java(874:31-874:35),"null"
726,BINARYOPERATOR,"==",Ex21.java(886:14-886:43),"entry.mParent.mChild == entry"
727,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(888:18-888:23),"entry"
728,IFSTATEMENT,"",Ex21.java(888:14-896:15),"if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }"
729,COMPOUNDSTATEMENT,"",Ex21.java(888:40-890:15),"{
	                entry.mParent.mChild = entry.mNext;
	            }"
730,COMPOUNDSTATEMENT,"",Ex21.java(894:19-896:15),"{
	                entry.mParent.mChild = null;
	            }"
731,BINARYOPERATOR,"!=",Ex21.java(888:18-888:38),"entry.mNext != entry"
732,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(889:18-889:23),"entry"
733,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(895:18-895:23),"entry"
734,BINARYOPERATOR,"=",Ex21.java(895:18-895:46),"entry.mParent.mChild = null;"
735,MEMBEREXPRESSION,"mChild",Ex21.java(895:18-895:38),"entry.mParent.mChild"
736,LITERAL,"",Ex21.java(895:41-895:45),"null"
737,MEMBEREXPRESSION,"mParent",Ex21.java(895:18-895:31),"entry.mParent"
738,MEMBEREXPRESSION,"mNext",Ex21.java(888:18-888:29),"entry.mNext"
739,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(888:33-888:38),"entry"
740,BINARYOPERATOR,"=",Ex21.java(889:18-889:53),"entry.mParent.mChild = entry.mNext;"
741,MEMBEREXPRESSION,"mChild",Ex21.java(889:18-889:38),"entry.mParent.mChild"
742,MEMBEREXPRESSION,"mNext",Ex21.java(889:41-889:52),"entry.mNext"
743,MEMBEREXPRESSION,"mParent",Ex21.java(889:18-889:31),"entry.mParent"
744,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(889:41-889:46),"entry"
745,MEMBEREXPRESSION,"mChild",Ex21.java(886:14-886:34),"entry.mParent.mChild"
746,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(886:38-886:43),"entry"
747,MEMBEREXPRESSION,"mParent",Ex21.java(886:14-886:27),"entry.mParent"
748,VARIABLEDECLARATION,"this",,""
749,COMPOUNDSTATEMENT,"",Ex21.java(780:73-834:7),"{
	        /* There are four cases depending on whether the lists are null or not.
	         * We consider each separately.
	         */
	        if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }
	    }"
750,PARAMVARIABLEDECLARATION,"one",Ex21.java(780:45-780:57),"Entry<T> one"
751,PARAMVARIABLEDECLARATION,"two",Ex21.java(780:59-780:71),"Entry<T> two"
752,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(784:14-784:17),"one"
753,RETURNSTATEMENT,"",,""
754,IFSTATEMENT,"",Ex21.java(784:10-833:11),"if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }"
755,BINARYOPERATOR,"&&",Ex21.java(784:14-784:40),"one == null && two == null"
756,COMPOUNDSTATEMENT,"",Ex21.java(784:42-786:11),"{ // Both null, resulting list is null.
	            return null;
	        }"
757,IFSTATEMENT,"",Ex21.java(787:15-833:11),"if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }"
758,LITERAL,"",Ex21.java(785:21-785:25),"null"
759,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(787:19-787:22),"one"
760,RETURNSTATEMENT,"",Ex21.java(785:14-785:26),"return null;"
761,BINARYOPERATOR,"==",Ex21.java(784:14-784:25),"one == null"
762,BINARYOPERATOR,"==",Ex21.java(784:29-784:40),"two == null"
763,LITERAL,"",Ex21.java(784:21-784:25),"null"
764,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(784:29-784:32),"two"
765,LITERAL,"",Ex21.java(784:36-784:40),"null"
766,BINARYOPERATOR,"&&",Ex21.java(787:19-787:45),"one != null && two == null"
767,COMPOUNDSTATEMENT,"",Ex21.java(787:47-789:11),"{ // Two is null, result is one.
	            return one;
	        }"
768,IFSTATEMENT,"",Ex21.java(790:15-833:11),"if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }"
769,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(788:21-788:24),"one"
770,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(790:19-790:22),"one"
771,BINARYOPERATOR,"!=",Ex21.java(787:19-787:30),"one != null"
772,BINARYOPERATOR,"==",Ex21.java(787:34-787:45),"two == null"
773,LITERAL,"",Ex21.java(787:26-787:30),"null"
774,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(787:34-787:37),"two"
775,LITERAL,"",Ex21.java(787:41-787:45),"null"
776,RETURNSTATEMENT,"",Ex21.java(788:14-788:25),"return one;"
777,BINARYOPERATOR,"&&",Ex21.java(790:19-790:45),"one == null && two != null"
778,COMPOUNDSTATEMENT,"",Ex21.java(790:47-792:11),"{ // One is null, result is two.
	            return two;
	        }"
779,COMPOUNDSTATEMENT,"",Ex21.java(793:15-833:11),"{ // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }"
780,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(791:21-791:24),"two"
781,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(825:33-825:36),"one"
782,DECLARATIONSTATEMENT,"",Ex21.java(825:14-825:43),"Entry<T> oneNext = one.mNext;"
783,BINARYOPERATOR,"=",Ex21.java(826:14-826:36),"one.mNext = two.mNext;"
784,BINARYOPERATOR,"=",Ex21.java(827:14-827:36),"one.mNext.mPrev = one;"
785,BINARYOPERATOR,"=",Ex21.java(828:14-828:34),"two.mNext = oneNext;"
786,BINARYOPERATOR,"=",Ex21.java(829:14-829:36),"two.mNext.mPrev = two;"
787,RETURNSTATEMENT,"",Ex21.java(832:14-832:62),"return one.mPriority < two.mPriority? one : two;"
788,VARIABLEDECLARATION,"oneNext",Ex21.java(825:23-825:42),"oneNext = one.mNext"
789,MEMBEREXPRESSION,"mNext",Ex21.java(828:14-828:23),"two.mNext"
790,DECLAREDREFERENCEEXPRESSION,"oneNext",Ex21.java(828:26-828:33),"oneNext"
791,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(829:14-829:17),"two"
792,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(828:14-828:17),"two"
793,MEMBEREXPRESSION,"mPrev",Ex21.java(829:14-829:29),"two.mNext.mPrev"
794,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(829:32-829:35),"two"
795,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(832:21-832:24),"one"
796,MEMBEREXPRESSION,"mNext",Ex21.java(829:14-829:23),"two.mNext"
797,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(826:14-826:17),"one"
798,MEMBEREXPRESSION,"mNext",Ex21.java(825:33-825:42),"one.mNext"
799,MEMBEREXPRESSION,"mNext",Ex21.java(826:14-826:23),"one.mNext"
800,MEMBEREXPRESSION,"mNext",Ex21.java(826:26-826:35),"two.mNext"
801,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(827:14-827:17),"one"
802,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(826:26-826:29),"two"
803,MEMBEREXPRESSION,"mPrev",Ex21.java(827:14-827:29),"one.mNext.mPrev"
804,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(827:32-827:35),"one"
805,MEMBEREXPRESSION,"mNext",Ex21.java(827:14-827:23),"one.mNext"
806,CONDITIONALEXPRESSION,"",Ex21.java(832:21-832:61),"one.mPriority < two.mPriority? one : two"
807,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(832:52-832:55),"one"
808,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(832:58-832:61),"two"
809,BINARYOPERATOR,"<",Ex21.java(832:21-832:50),"one.mPriority < two.mPriority"
810,MEMBEREXPRESSION,"mPriority",Ex21.java(832:21-832:34),"one.mPriority"
811,MEMBEREXPRESSION,"mPriority",Ex21.java(832:37-832:50),"two.mPriority"
812,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(832:37-832:40),"two"
813,BINARYOPERATOR,"==",Ex21.java(790:19-790:30),"one == null"
814,BINARYOPERATOR,"!=",Ex21.java(790:34-790:45),"two != null"
815,LITERAL,"",Ex21.java(790:26-790:30),"null"
816,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(790:34-790:37),"two"
817,LITERAL,"",Ex21.java(790:41-790:45),"null"
818,RETURNSTATEMENT,"",Ex21.java(791:14-791:25),"return two;"
819,VARIABLEDECLARATION,"this",,""
820,COMPOUNDSTATEMENT,"",Ex21.java(505:28-509:7),"{
	        if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");
	        return mMin;
	    }"
821,CALLEXPRESSION,"isEmpty",Ex21.java(506:14-506:23),"isEmpty()"
822,RETURNSTATEMENT,"",Ex21.java(508:10-508:22),"return mMin;"
823,IFSTATEMENT,"",Ex21.java(506:10-507:65),"if (isEmpty())
	            throw new NoSuchElementException(""Heap is empty."");"
824,UNARYOPERATOR,"throw",Ex21.java(507:14-507:65),"throw new NoSuchElementException(""Heap is empty."");"
825,LITERAL,"",Ex21.java(507:47-507:63),"""Heap is empty."""
826,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(508:17-508:21),"this"
827,NEWEXPRESSION,"",Ex21.java(507:20-507:64),"new NoSuchElementException(""Heap is empty."")"
828,CONSTRUCTEXPRESSION,"",Ex21.java(507:20-507:64),"new NoSuchElementException(""Heap is empty."")"
829,MEMBEREXPRESSION,"mMin",Ex21.java(508:17-508:21),"mMin"
830,LITERAL,"",Ex21.java(468:26-468:27),"0"
831,VARIABLEDECLARATION,"this",,""
832,COMPOUNDSTATEMENT,"",Ex21.java(759:50-762:7),"{
	        if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + "" is invalid."");
	    }"
833,PARAMVARIABLEDECLARATION,"priority",Ex21.java(759:33-759:48),"double priority"
834,DECLAREDREFERENCEEXPRESSION,"priority",Ex21.java(760:27-760:35),"priority"
835,RETURNSTATEMENT,"",,""
836,IFSTATEMENT,"",Ex21.java(760:10-761:76),"if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + "" is invalid."");"
837,UNARYOPERATOR,"throw",Ex21.java(761:14-761:76),"throw new IllegalArgumentException(priority + "" is invalid."");"
838,STATICCALLEXPRESSION,"isNaN",Ex21.java(760:14-760:36),"Double.isNaN(priority)"
839,DECLAREDREFERENCEEXPRESSION,"priority",Ex21.java(761:49-761:57),"priority"
840,NEWEXPRESSION,"",Ex21.java(761:20-761:75),"new IllegalArgumentException(priority + "" is invalid."")"
841,CONSTRUCTEXPRESSION,"",Ex21.java(761:20-761:75),"new IllegalArgumentException(priority + "" is invalid."")"
842,BINARYOPERATOR,"+",Ex21.java(761:49-761:74),"priority + "" is invalid."""
843,LITERAL,"",Ex21.java(761:60-761:74),""" is invalid."""
844,FIELDDECLARATION,"this",,""
845,FIELDDECLARATION,"mDegree",Ex21.java(411:10-411:38),"mDegree = 0"
846,FIELDDECLARATION,"mIsMarked",Ex21.java(412:10-412:44),"mIsMarked = false"
847,FIELDDECLARATION,"mNext",Ex21.java(414:10-414:33),"mNext"
848,FIELDDECLARATION,"mPrev",Ex21.java(415:10-415:33),"mPrev"
849,FIELDDECLARATION,"mParent",Ex21.java(417:10-417:35),"mParent"
850,FIELDDECLARATION,"mChild",Ex21.java(419:10-419:34),"mChild"
851,FIELDDECLARATION,"mElem",Ex21.java(421:10-421:31),"mElem"
852,FIELDDECLARATION,"mPriority",Ex21.java(422:10-422:35),"mPriority"
853,METHODDECLARATION,"getValue",Ex21.java(429:10-431:11),"public T getValue() {
	            return mElem;
	        }"
854,METHODDECLARATION,"setValue",Ex21.java(437:10-439:11),"public void setValue(T value) {
	            mElem = value;
	        }"
855,METHODDECLARATION,"getPriority",Ex21.java(446:10-448:11),"public double getPriority() {
	            return mPriority;
	        }"
856,CONSTRUCTORDECLARATION,"Entry",Ex21.java(457:10-461:11),"private Entry(T elem, double priority) {
	            mNext = mPrev = this;
	            mElem = elem;
	            mPriority = priority;
	        }"
857,COMPOUNDSTATEMENT,"",Ex21.java(457:49-461:11),"{
	            mNext = mPrev = this;
	            mElem = elem;
	            mPriority = priority;
	        }"
858,PARAMVARIABLEDECLARATION,"elem",Ex21.java(457:24-457:30),"T elem"
859,PARAMVARIABLEDECLARATION,"priority",Ex21.java(457:32-457:47),"double priority"
860,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(458:14-458:19),"this"
861,RETURNSTATEMENT,"",,""
862,BINARYOPERATOR,"=",Ex21.java(458:14-458:35),"mNext = mPrev = this;"
863,BINARYOPERATOR,"=",Ex21.java(459:14-459:27),"mElem = elem;"
864,BINARYOPERATOR,"=",Ex21.java(460:14-460:35),"mPriority = priority;"
865,MEMBEREXPRESSION,"mElem",Ex21.java(459:14-459:19),"mElem"
866,DECLAREDREFERENCEEXPRESSION,"elem",Ex21.java(459:22-459:26),"elem"
867,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(460:14-460:23),"this"
868,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(459:14-459:19),"this"
869,MEMBEREXPRESSION,"mPriority",Ex21.java(460:14-460:23),"mPriority"
870,DECLAREDREFERENCEEXPRESSION,"priority",Ex21.java(460:26-460:34),"priority"
871,MEMBEREXPRESSION,"mNext",Ex21.java(458:14-458:19),"mNext"
872,BINARYOPERATOR,"=",Ex21.java(458:22-458:34),"mPrev = this"
873,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(458:22-458:27),"this"
874,MEMBEREXPRESSION,"mPrev",Ex21.java(458:22-458:27),"mPrev"
875,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(458:30-458:34),"this"
876,VARIABLEDECLARATION,"this",,""
877,COMPOUNDSTATEMENT,"",Ex21.java(437:40-439:11),"{
	            mElem = value;
	        }"
878,PARAMVARIABLEDECLARATION,"value",Ex21.java(437:31-437:38),"T value"
879,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(438:14-438:19),"this"
880,RETURNSTATEMENT,"",,""
881,BINARYOPERATOR,"=",Ex21.java(438:14-438:28),"mElem = value;"
882,MEMBEREXPRESSION,"mElem",Ex21.java(438:14-438:19),"mElem"
883,DECLAREDREFERENCEEXPRESSION,"value",Ex21.java(438:22-438:27),"value"
884,VARIABLEDECLARATION,"this",,""
885,COMPOUNDSTATEMENT,"",Ex21.java(446:38-448:11),"{
	            return mPriority;
	        }"
886,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(447:21-447:30),"this"
887,RETURNSTATEMENT,"",Ex21.java(447:14-447:31),"return mPriority;"
888,MEMBEREXPRESSION,"mPriority",Ex21.java(447:21-447:30),"mPriority"
889,VARIABLEDECLARATION,"this",,""
890,COMPOUNDSTATEMENT,"",Ex21.java(429:30-431:11),"{
	            return mElem;
	        }"
891,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(430:21-430:26),"this"
892,RETURNSTATEMENT,"",Ex21.java(430:14-430:27),"return mElem;"
893,MEMBEREXPRESSION,"mElem",Ex21.java(430:21-430:26),"mElem"
894,LITERAL,"",Ex21.java(411:36-411:37),"0"
895,LITERAL,"",Ex21.java(412:38-412:43),"false"
896,VARIABLEDECLARATION,"this",,""
897,COMPOUNDSTATEMENT,"",Ex21.java(725:66-732:7),"{
	        checkPriority(newPriority);
	        if (newPriority > entry.mPriority)
	            throw new IllegalArgumentException(""New priority exceeds old."");

	        /* Forward this to a helper function. */
	        decreaseKeyUnchecked(entry, newPriority);
	    }"
898,PARAMVARIABLEDECLARATION,"entry",Ex21.java(725:30-725:44),"Entry<T> entry"
899,PARAMVARIABLEDECLARATION,"newPriority",Ex21.java(725:46-725:64),"double newPriority"
900,DECLAREDREFERENCEEXPRESSION,"newPriority",Ex21.java(726:24-726:35),"newPriority"
901,RETURNSTATEMENT,"",,""
902,CALLEXPRESSION,"checkPriority",Ex21.java(726:10-726:37),"checkPriority(newPriority);"
903,IFSTATEMENT,"",Ex21.java(727:10-728:78),"if (newPriority > entry.mPriority)
	            throw new IllegalArgumentException(""New priority exceeds old."");"
904,CALLEXPRESSION,"decreaseKeyUnchecked",Ex21.java(731:10-731:51),"decreaseKeyUnchecked(entry, newPriority);"
905,UNARYOPERATOR,"throw",Ex21.java(728:14-728:78),"throw new IllegalArgumentException(""New priority exceeds old."");"
906,BINARYOPERATOR,">",Ex21.java(727:14-727:43),"newPriority > entry.mPriority"
907,LITERAL,"",Ex21.java(728:49-728:76),"""New priority exceeds old."""
908,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(731:31-731:36),"entry"
909,DECLAREDREFERENCEEXPRESSION,"newPriority",Ex21.java(727:14-727:25),"newPriority"
910,MEMBEREXPRESSION,"mPriority",Ex21.java(727:28-727:43),"entry.mPriority"
911,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(727:28-727:33),"entry"
912,NEWEXPRESSION,"",Ex21.java(728:20-728:77),"new IllegalArgumentException(""New priority exceeds old."")"
913,CONSTRUCTEXPRESSION,"",Ex21.java(728:20-728:77),"new IllegalArgumentException(""New priority exceeds old."")"
914,DECLAREDREFERENCEEXPRESSION,"newPriority",Ex21.java(731:38-731:49),"newPriority"
915,FIELDDECLARATION,"this",,""
916,METHODDECLARATION,"mst",Ex21.java(108:6-164:7),"public static <T> UndirectedGraph<T> mst(UndirectedGraph<T> graph) {
	        /* The Fibonacci heap we'll use to select nodes efficiently. */
	        FibonacciHeap<T> pq = new FibonacciHeap<T>();

	        /* This Fibonacci heap hands back internal handles to the nodes it
	         * stores.  This map will associate each node with its entry in the
	         * Fibonacci heap.
	         */
	        Map<T, FibonacciHeap.Entry<T>> entries = new HashMap<T, FibonacciHeap.Entry<T>>();

	        /* The graph which will hold the resulting MST. */
	        UndirectedGraph<T> result = new Ex21().new UndirectedGraph<T>();

	        /* As an edge case, if the graph is empty, just hand back the empty
	         * graph.
	         */
	        if (graph.isEmpty())
	            return result;

	        /* Pick an arbitrary starting node. */
	        T startNode = graph.iterator().next();

	        /* Add it as a node in the graph.  During this process, we'll use
	         * whether a node is in the result graph or not as a sentinel of
	         * whether it's already been picked.
	         */
	        result.addNode(startNode);

	        /* Begin by adding all outgoing edges of this start node to the
	         * Fibonacci heap.
	         */
	        addOutgoingEdges(startNode, graph, pq, result, entries);

	        /* Now, until we have added |V| - 1 edges to the graph, continously
	         * pick a node and determine which edge to add.
	         */
	        for (int i = 0; i < graph.size() - 1; ++i) {
	            /* Grab the cheapest node we can add. */
	            T toAdd = pq.dequeueMin().getValue();

	            /* Determine which edge we should pick to add to the MST.  We'll
	             * do this by getting the endpoint of the edge leaving the current
	             * node that's of minimum cost and that enters the visited edges.
	             */
	            T endpoint = minCostEndpoint(toAdd, graph, result);

	            /* Add this edge to the graph. */
	            result.addNode(toAdd);
	            result.addEdge(toAdd, endpoint, graph.edgeCost(toAdd, endpoint));

	            /* Explore outward from this node. */
	            addOutgoingEdges(toAdd, graph, pq, result, entries);
	        }

	        /* Hand back the generated graph. */
	        return result;
	    }"
917,METHODDECLARATION,"minCostEndpoint",Ex21.java(176:6-203:7),"private static <T> T minCostEndpoint(T node, UndirectedGraph<T> graph, 
	                                         UndirectedGraph<T> result) {
	        /* Track the best endpoint so far and its cost, initially null and
	         * +infinity.
	         */
	        T endpoint = null;
	        double leastCost = Double.POSITIVE_INFINITY;

	        /* Scan each node, checking whether it's a candidate. */
	        for (Map.Entry<T, Double> entry : graph.edgesFrom(node).entrySet()) {
	            /* If the endpoint isn't in the nodes constructed so far, don't
	             * consider it.
	             */
	            if (!result.containsNode(entry.getKey())) continue;

	            /* If the edge costs more than what we know, skip it. */
	            if (entry.getValue() >= leastCost) continue;

	            /* Otherwise, update our guess to be this node. */
	            endpoint = entry.getKey();
	            leastCost = entry.getValue();
	        }

	        /* Hand back the result.  We're guaranteed to have found something,
	         * since otherwise we couldn't have dequeued this node.
	         */
	        return endpoint;
	    }"
918,METHODDECLARATION,"addOutgoingEdges",Ex21.java(222:6-250:7),"private static <T> void addOutgoingEdges(T node, UndirectedGraph<T> graph,
	                                             FibonacciHeap<T> pq,
	                                             UndirectedGraph<T> result,
	                                             Map<T, FibonacciHeap.Entry<T>> entries ) {
	        /* Start off by scanning over all edges emanating from our node. */
	        for (Map.Entry<T, Double> arc : graph.edgesFrom(node).entrySet()) {
	            /* Given this arc, there are four possibilities.
	             *
	             * 1. This endpoint has already been added to the graph.  If so,
	             *    we ignore the edge since it would form a cycle.
	             * 2. This endpoint is not in the graph and has never been in
	             *    the heap.  Then we add it to the heap.
	             * 3. This endpoint is in the graph, but this is a better edge.
	             *    Then we use decreaseKey to update its priority.
	             * 4. This endpoint is in the graph, but there is a better edge
	             *    to it.  In that case, we similarly ignore it.
	             */
	            if (result.containsNode(arc.getKey())) continue; // Case 1

	            if (!entries.containsKey(arc.getKey())) { // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }
	            else if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }

	            // Case 4 handled implicitly by doing nothing.
	        }
	    }"
919,CONSTRUCTORDECLARATION,"Ex21.Prim",,""
920,VARIABLEDECLARATION,"this",,""
921,COMPOUNDSTATEMENT,"",Ex21.java(177:70-203:7),"{
	        /* Track the best endpoint so far and its cost, initially null and
	         * +infinity.
	         */
	        T endpoint = null;
	        double leastCost = Double.POSITIVE_INFINITY;

	        /* Scan each node, checking whether it's a candidate. */
	        for (Map.Entry<T, Double> entry : graph.edgesFrom(node).entrySet()) {
	            /* If the endpoint isn't in the nodes constructed so far, don't
	             * consider it.
	             */
	            if (!result.containsNode(entry.getKey())) continue;

	            /* If the edge costs more than what we know, skip it. */
	            if (entry.getValue() >= leastCost) continue;

	            /* Otherwise, update our guess to be this node. */
	            endpoint = entry.getKey();
	            leastCost = entry.getValue();
	        }

	        /* Hand back the result.  We're guaranteed to have found something,
	         * since otherwise we couldn't have dequeued this node.
	         */
	        return endpoint;
	    }"
922,PARAMVARIABLEDECLARATION,"node",Ex21.java(176:43-176:49),"T node"
923,PARAMVARIABLEDECLARATION,"graph",Ex21.java(176:51-176:75),"UndirectedGraph<T> graph"
924,PARAMVARIABLEDECLARATION,"result",Ex21.java(177:43-177:68),"UndirectedGraph<T> result"
925,LITERAL,"",Ex21.java(181:23-181:27),"null"
926,RETURNSTATEMENT,"",Ex21.java(202:10-202:26),"return endpoint;"
927,DECLARATIONSTATEMENT,"",Ex21.java(181:10-181:28),"T endpoint = null;"
928,DECLARATIONSTATEMENT,"",Ex21.java(182:10-182:54),"double leastCost = Double.POSITIVE_INFINITY;"
929,FOREACHSTATEMENT,"",Ex21.java(185:10-197:11),"for (Map.Entry<T, Double> entry : graph.edgesFrom(node).entrySet()) {
	            /* If the endpoint isn't in the nodes constructed so far, don't
	             * consider it.
	             */
	            if (!result.containsNode(entry.getKey())) continue;

	            /* If the edge costs more than what we know, skip it. */
	            if (entry.getValue() >= leastCost) continue;

	            /* Otherwise, update our guess to be this node. */
	            endpoint = entry.getKey();
	            leastCost = entry.getValue();
	        }"
930,VARIABLEDECLARATION,"endpoint",Ex21.java(181:12-181:27),"endpoint = null"
931,VARIABLEDECLARATION,"leastCost",Ex21.java(182:17-182:53),"leastCost = Double.POSITIVE_INFINITY"
932,MEMBEREXPRESSION,"POSITIVE_INFINITY",Ex21.java(182:29-182:53),"Double.POSITIVE_INFINITY"
933,DECLAREDREFERENCEEXPRESSION,"Double",Ex21.java(182:29-182:35),"Double"
934,DECLARATIONSTATEMENT,"",Ex21.java(185:15-185:41),"Map.Entry<T, Double> entry"
935,MEMBERCALLEXPRESSION,"entrySet",Ex21.java(185:44-185:76),"graph.edgesFrom(node).entrySet()"
936,COMPOUNDSTATEMENT,"",Ex21.java(185:78-197:11),"{
	            /* If the endpoint isn't in the nodes constructed so far, don't
	             * consider it.
	             */
	            if (!result.containsNode(entry.getKey())) continue;

	            /* If the edge costs more than what we know, skip it. */
	            if (entry.getValue() >= leastCost) continue;

	            /* Otherwise, update our guess to be this node. */
	            endpoint = entry.getKey();
	            leastCost = entry.getValue();
	        }"
937,VARIABLEDECLARATION,"entry",Ex21.java(185:36-185:41),"entry"
938,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(189:19-189:25),"result"
939,DECLAREDREFERENCEEXPRESSION,"endpoint",Ex21.java(202:17-202:25),"endpoint"
940,UNINITIALIZEDVALUE,"Uninitialized Value",,""
941,IFSTATEMENT,"",Ex21.java(189:14-189:65),"if (!result.containsNode(entry.getKey())) continue;"
942,IFSTATEMENT,"",Ex21.java(192:14-192:58),"if (entry.getValue() >= leastCost) continue;"
943,BINARYOPERATOR,"=",Ex21.java(195:14-195:40),"endpoint = entry.getKey();"
944,BINARYOPERATOR,"=",Ex21.java(196:14-196:43),"leastCost = entry.getValue();"
945,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(185:44-185:49),"graph"
946,BINARYOPERATOR,">=",Ex21.java(192:18-192:47),"entry.getValue() >= leastCost"
947,CONTINUESTATEMENT,"",Ex21.java(192:49-192:58),"continue;"
948,DECLAREDREFERENCEEXPRESSION,"endpoint",Ex21.java(195:14-195:22),"endpoint"
949,MEMBERCALLEXPRESSION,"getValue",Ex21.java(192:18-192:34),"entry.getValue()"
950,DECLAREDREFERENCEEXPRESSION,"leastCost",Ex21.java(192:38-192:47),"leastCost"
951,DECLAREDREFERENCEEXPRESSION,"getValue",Ex21.java(192:24-192:32),"getValue"
952,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(192:18-192:23),"entry"
953,UNARYOPERATOR,"!",Ex21.java(189:18-189:54),"!result.containsNode(entry.getKey())"
954,CONTINUESTATEMENT,"",Ex21.java(189:56-189:65),"continue;"
955,MEMBERCALLEXPRESSION,"containsNode",Ex21.java(189:19-189:54),"result.containsNode(entry.getKey())"
956,DECLAREDREFERENCEEXPRESSION,"containsNode",Ex21.java(189:26-189:38),"containsNode"
957,METHODDECLARATION,"containsNode",,""
958,MEMBERCALLEXPRESSION,"getKey",Ex21.java(189:39-189:53),"entry.getKey()"
959,DECLAREDREFERENCEEXPRESSION,"getKey",Ex21.java(189:45-189:51),"getKey"
960,PARAMVARIABLEDECLARATION,"k0",,""
961,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(189:39-189:44),"entry"
962,MEMBERCALLEXPRESSION,"getKey",Ex21.java(195:25-195:39),"entry.getKey()"
963,DECLAREDREFERENCEEXPRESSION,"leastCost",Ex21.java(196:14-196:23),"leastCost"
964,DECLAREDREFERENCEEXPRESSION,"getKey",Ex21.java(195:31-195:37),"getKey"
965,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(195:25-195:30),"entry"
966,MEMBERCALLEXPRESSION,"getValue",Ex21.java(196:26-196:42),"entry.getValue()"
967,DECLAREDREFERENCEEXPRESSION,"entry",Ex21.java(196:26-196:31),"entry"
968,DECLAREDREFERENCEEXPRESSION,"getValue",Ex21.java(196:32-196:40),"getValue"
969,DECLAREDREFERENCEEXPRESSION,"entrySet",Ex21.java(185:66-185:74),"entrySet"
970,MEMBERCALLEXPRESSION,"edgesFrom",Ex21.java(185:44-185:65),"graph.edgesFrom(node)"
971,DECLAREDREFERENCEEXPRESSION,"edgesFrom",Ex21.java(185:50-185:59),"edgesFrom"
972,METHODDECLARATION,"edgesFrom",Ex21.java(346:6-353:7),"public Map<T, Double> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Map<T, Double> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException(""Source node does not exist."");

	        return Collections.unmodifiableMap(arcs);
	    }"
973,DECLAREDREFERENCEEXPRESSION,"node",Ex21.java(185:60-185:64),"node"
974,PARAMVARIABLEDECLARATION,"node",Ex21.java(346:38-346:44),"T node"
975,VARIABLEDECLARATION,"this",,""
976,COMPOUNDSTATEMENT,"",Ex21.java(108:73-164:7),"{
	        /* The Fibonacci heap we'll use to select nodes efficiently. */
	        FibonacciHeap<T> pq = new FibonacciHeap<T>();

	        /* This Fibonacci heap hands back internal handles to the nodes it
	         * stores.  This map will associate each node with its entry in the
	         * Fibonacci heap.
	         */
	        Map<T, FibonacciHeap.Entry<T>> entries = new HashMap<T, FibonacciHeap.Entry<T>>();

	        /* The graph which will hold the resulting MST. */
	        UndirectedGraph<T> result = new Ex21().new UndirectedGraph<T>();

	        /* As an edge case, if the graph is empty, just hand back the empty
	         * graph.
	         */
	        if (graph.isEmpty())
	            return result;

	        /* Pick an arbitrary starting node. */
	        T startNode = graph.iterator().next();

	        /* Add it as a node in the graph.  During this process, we'll use
	         * whether a node is in the result graph or not as a sentinel of
	         * whether it's already been picked.
	         */
	        result.addNode(startNode);

	        /* Begin by adding all outgoing edges of this start node to the
	         * Fibonacci heap.
	         */
	        addOutgoingEdges(startNode, graph, pq, result, entries);

	        /* Now, until we have added |V| - 1 edges to the graph, continously
	         * pick a node and determine which edge to add.
	         */
	        for (int i = 0; i < graph.size() - 1; ++i) {
	            /* Grab the cheapest node we can add. */
	            T toAdd = pq.dequeueMin().getValue();

	            /* Determine which edge we should pick to add to the MST.  We'll
	             * do this by getting the endpoint of the edge leaving the current
	             * node that's of minimum cost and that enters the visited edges.
	             */
	            T endpoint = minCostEndpoint(toAdd, graph, result);

	            /* Add this edge to the graph. */
	            result.addNode(toAdd);
	            result.addEdge(toAdd, endpoint, graph.edgeCost(toAdd, endpoint));

	            /* Explore outward from this node. */
	            addOutgoingEdges(toAdd, graph, pq, result, entries);
	        }

	        /* Hand back the generated graph. */
	        return result;
	    }"
977,PARAMVARIABLEDECLARATION,"graph",Ex21.java(108:47-108:71),"UndirectedGraph<T> graph"
978,CONSTRUCTEXPRESSION,"",Ex21.java(110:32-110:54),"new FibonacciHeap<T>()"
979,RETURNSTATEMENT,"",Ex21.java(163:10-163:24),"return result;"
980,DECLARATIONSTATEMENT,"",Ex21.java(110:10-110:55),"FibonacciHeap<T> pq = new FibonacciHeap<T>();"
981,DECLARATIONSTATEMENT,"",Ex21.java(116:10-116:92),"Map<T, FibonacciHeap.Entry<T>> entries = new HashMap<T, FibonacciHeap.Entry<T>>();"
982,DECLARATIONSTATEMENT,"",Ex21.java(119:10-119:74),"UndirectedGraph<T> result = new Ex21().new UndirectedGraph<T>();"
983,IFSTATEMENT,"",Ex21.java(124:10-125:28),"if (graph.isEmpty())
	            return result;"
984,DECLARATIONSTATEMENT,"",Ex21.java(128:10-128:48),"T startNode = graph.iterator().next();"
985,MEMBERCALLEXPRESSION,"addNode",Ex21.java(134:10-134:36),"result.addNode(startNode);"
986,CALLEXPRESSION,"addOutgoingEdges",Ex21.java(139:10-139:66),"addOutgoingEdges(startNode, graph, pq, result, entries);"
987,FORSTATEMENT,"",Ex21.java(144:10-160:11),"for (int i = 0; i < graph.size() - 1; ++i) {
	            /* Grab the cheapest node we can add. */
	            T toAdd = pq.dequeueMin().getValue();

	            /* Determine which edge we should pick to add to the MST.  We'll
	             * do this by getting the endpoint of the edge leaving the current
	             * node that's of minimum cost and that enters the visited edges.
	             */
	            T endpoint = minCostEndpoint(toAdd, graph, result);

	            /* Add this edge to the graph. */
	            result.addNode(toAdd);
	            result.addEdge(toAdd, endpoint, graph.edgeCost(toAdd, endpoint));

	            /* Explore outward from this node. */
	            addOutgoingEdges(toAdd, graph, pq, result, entries);
	        }"
988,VARIABLEDECLARATION,"pq",Ex21.java(110:27-110:54),"pq = new FibonacciHeap<T>()"
989,VARIABLEDECLARATION,"entries",Ex21.java(116:41-116:91),"entries = new HashMap<T, FibonacciHeap.Entry<T>>()"
990,VARIABLEDECLARATION,"result",Ex21.java(119:29-119:73),"result = new Ex21().new UndirectedGraph<T>()"
991,VARIABLEDECLARATION,"startNode",Ex21.java(128:12-128:47),"startNode = graph.iterator().next()"
992,COMPOUNDSTATEMENT,"",Ex21.java(144:53-160:11),"{
	            /* Grab the cheapest node we can add. */
	            T toAdd = pq.dequeueMin().getValue();

	            /* Determine which edge we should pick to add to the MST.  We'll
	             * do this by getting the endpoint of the edge leaving the current
	             * node that's of minimum cost and that enters the visited edges.
	             */
	            T endpoint = minCostEndpoint(toAdd, graph, result);

	            /* Add this edge to the graph. */
	            result.addNode(toAdd);
	            result.addEdge(toAdd, endpoint, graph.edgeCost(toAdd, endpoint));

	            /* Explore outward from this node. */
	            addOutgoingEdges(toAdd, graph, pq, result, entries);
	        }"
993,DECLARATIONSTATEMENT,"",Ex21.java(144:15-144:24),"int i = 0"
994,BINARYOPERATOR,"<",Ex21.java(144:26-144:46),"i < graph.size() - 1"
995,UNARYOPERATOR,"++",Ex21.java(144:48-144:51),"++i"
996,VARIABLEDECLARATION,"i",Ex21.java(144:19-144:24),"i = 0"
997,DECLAREDREFERENCEEXPRESSION,"pq",Ex21.java(146:24-146:26),"pq"
998,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(163:17-163:23),"result"
999,DECLARATIONSTATEMENT,"",Ex21.java(146:14-146:51),"T toAdd = pq.dequeueMin().getValue();"
1000,DECLARATIONSTATEMENT,"",Ex21.java(152:14-152:65),"T endpoint = minCostEndpoint(toAdd, graph, result);"
1001,MEMBERCALLEXPRESSION,"addNode",Ex21.java(155:14-155:36),"result.addNode(toAdd);"
1002,MEMBERCALLEXPRESSION,"addEdge",Ex21.java(156:14-156:79),"result.addEdge(toAdd, endpoint, graph.edgeCost(toAdd, endpoint));"
1003,CALLEXPRESSION,"addOutgoingEdges",Ex21.java(159:14-159:66),"addOutgoingEdges(toAdd, graph, pq, result, entries);"
1004,VARIABLEDECLARATION,"toAdd",Ex21.java(146:16-146:50),"toAdd = pq.dequeueMin().getValue()"
1005,VARIABLEDECLARATION,"endpoint",Ex21.java(152:16-152:64),"endpoint = minCostEndpoint(toAdd, graph, result)"
1006,DECLAREDREFERENCEEXPRESSION,"i",Ex21.java(144:50-144:51),"i"
1007,METHODDECLARATION,"addOutgoingEdges",Ex21.java(214:6-242:7),"private static <T> void addOutgoingEdges(T node, UndirectedGraph<T> graph,
	                                             FibonacciHeap<T> pq,
	                                             UndirectedGraph<T> result,
	                                             Map<T, FibonacciHeap.Entry<T>> entries ) {
	        /* Start off by scanning over all edges emanating from our node. */
	        for (Map.Entry<T, Double> arc : graph.edgesFrom(node).entrySet()) {
	            /* Given this arc, there are four possibilities.
	             *
	             * 1. This endpoint has already been added to the graph.  If so,
	             *    we ignore the edge since it would form a cycle.
	             * 2. This endpoint is not in the graph and has never been in
	             *    the heap.  Then we add it to the heap.
	             * 3. This endpoint is in the graph, but this is a better edge.
	             *    Then we use decreaseKey to update its priority.
	             * 4. This endpoint is in the graph, but there is a better edge
	             *    to it.  In that case, we similarly ignore it.
	             */
	            if (result.containsNode(arc.getKey())) continue; // Case 1

	            if (!entries.containsKey(arc.getKey())) { // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }
	            else if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }

	            // Case 4 handled implicitly by doing nothing.
	        }
	    }"
1008,DECLAREDREFERENCEEXPRESSION,"toAdd",Ex21.java(159:31-159:36),"toAdd"
1009,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(159:38-159:43),"graph"
1010,DECLAREDREFERENCEEXPRESSION,"pq",Ex21.java(159:45-159:47),"pq"
1011,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(159:49-159:55),"result"
1012,DECLAREDREFERENCEEXPRESSION,"entries",Ex21.java(159:57-159:64),"entries"
1013,PARAMVARIABLEDECLARATION,"pq",Ex21.java(215:47-215:66),"FibonacciHeap<T> pq"
1014,PARAMVARIABLEDECLARATION,"node",Ex21.java(214:47-214:53),"T node"
1015,PARAMVARIABLEDECLARATION,"result",Ex21.java(216:47-216:72),"UndirectedGraph<T> result"
1016,PARAMVARIABLEDECLARATION,"graph",Ex21.java(214:55-214:79),"UndirectedGraph<T> graph"
1017,PARAMVARIABLEDECLARATION,"entries",Ex21.java(217:47-217:85),"Map<T, FibonacciHeap.Entry<T>> entries"
1018,DECLAREDREFERENCEEXPRESSION,"toAdd",Ex21.java(152:43-152:48),"toAdd"
1019,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(155:14-155:20),"result"
1020,CALLEXPRESSION,"minCostEndpoint",Ex21.java(152:27-152:64),"minCostEndpoint(toAdd, graph, result)"
1021,METHODDECLARATION,"minCostEndpoint",Ex21.java(168:6-195:7),"private static <T> T minCostEndpoint(T node, UndirectedGraph<T> graph, 
	                                         UndirectedGraph<T> result) {
	        /* Track the best endpoint so far and its cost, initially null and
	         * +infinity.
	         */
	        T endpoint = null;
	        double leastCost = Double.POSITIVE_INFINITY;

	        /* Scan each node, checking whether it's a candidate. */
	        for (Map.Entry<T, Double> entry : graph.edgesFrom(node).entrySet()) {
	            /* If the endpoint isn't in the nodes constructed so far, don't
	             * consider it.
	             */
	            if (!result.containsNode(entry.getKey())) continue;

	            /* If the edge costs more than what we know, skip it. */
	            if (entry.getValue() >= leastCost) continue;

	            /* Otherwise, update our guess to be this node. */
	            endpoint = entry.getKey();
	            leastCost = entry.getValue();
	        }

	        /* Hand back the result.  We're guaranteed to have found something,
	         * since otherwise we couldn't have dequeued this node.
	         */
	        return endpoint;
	    }"
1022,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(152:50-152:55),"graph"
1023,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(152:57-152:63),"result"
1024,PARAMVARIABLEDECLARATION,"graph",Ex21.java(168:51-168:75),"UndirectedGraph<T> graph"
1025,PARAMVARIABLEDECLARATION,"node",Ex21.java(168:43-168:49),"T node"
1026,PARAMVARIABLEDECLARATION,"result",Ex21.java(169:43-169:68),"UndirectedGraph<T> result"
1027,MEMBERCALLEXPRESSION,"getValue",Ex21.java(146:24-146:50),"pq.dequeueMin().getValue()"
1028,DECLAREDREFERENCEEXPRESSION,"getValue",Ex21.java(146:40-146:48),"getValue"
1029,METHODDECLARATION,"getValue",Ex21.java(421:10-423:11),"public T getValue() {
	            return mElem;
	        }"
1030,MEMBERCALLEXPRESSION,"dequeueMin",Ex21.java(146:24-146:39),"pq.dequeueMin()"
1031,DECLAREDREFERENCEEXPRESSION,"dequeueMin",Ex21.java(146:27-146:37),"dequeueMin"
1032,DECLAREDREFERENCEEXPRESSION,"addNode",Ex21.java(155:21-155:28),"addNode"
1033,METHODDECLARATION,"addNode",Ex21.java(260:6-268:7),"public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashMap<T, Double>());
	        return true;
	    }"
1034,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(156:14-156:20),"result"
1035,DECLAREDREFERENCEEXPRESSION,"toAdd",Ex21.java(155:29-155:34),"toAdd"
1036,PARAMVARIABLEDECLARATION,"node",Ex21.java(260:29-260:35),"T node"
1037,DECLAREDREFERENCEEXPRESSION,"addEdge",Ex21.java(156:21-156:28),"addEdge"
1038,METHODDECLARATION,"addEdge",Ex21.java(282:6-290:7),"public void addEdge(T one, T two, double length) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Add the edge in both directions. */
	        mGraph.get(one).put(two, length);
	        mGraph.get(two).put(one, length);
	    }"
1039,MEMBERCALLEXPRESSION,"edgeCost",Ex21.java(156:46-156:77),"graph.edgeCost(toAdd, endpoint)"
1040,DECLAREDREFERENCEEXPRESSION,"endpoint",Ex21.java(156:36-156:44),"endpoint"
1041,PARAMVARIABLEDECLARATION,"two",Ex21.java(282:33-282:38),"T two"
1042,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(156:46-156:51),"graph"
1043,DECLAREDREFERENCEEXPRESSION,"toAdd",Ex21.java(156:29-156:34),"toAdd"
1044,PARAMVARIABLEDECLARATION,"one",Ex21.java(282:26-282:31),"T one"
1045,DECLAREDREFERENCEEXPRESSION,"edgeCost",Ex21.java(156:52-156:60),"edgeCost"
1046,METHODDECLARATION,"edgeCost",Ex21.java(322:6-336:7),"public double edgeCost(T one, T two) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");     
	        
	        /* Look up the edge between the two. */
	        Double result = mGraph.get(one).get(two);

	        /* If there is no edge here, report an error. */
	        if (result == null)
	            throw new NoSuchElementException(""Edge does not exist in the graph."");

	        /* Otherwise return the cost. */
	        return result;
	    }"
1047,PARAMVARIABLEDECLARATION,"length",Ex21.java(282:40-282:53),"double length"
1048,DECLAREDREFERENCEEXPRESSION,"endpoint",Ex21.java(156:68-156:76),"endpoint"
1049,DECLAREDREFERENCEEXPRESSION,"toAdd",Ex21.java(156:61-156:66),"toAdd"
1050,PARAMVARIABLEDECLARATION,"one",Ex21.java(322:29-322:34),"T one"
1051,PARAMVARIABLEDECLARATION,"two",Ex21.java(322:36-322:41),"T two"
1052,LITERAL,"",Ex21.java(144:23-144:24),"0"
1053,DECLAREDREFERENCEEXPRESSION,"i",Ex21.java(144:26-144:27),"i"
1054,BINARYOPERATOR,"-",Ex21.java(144:30-144:46),"graph.size() - 1"
1055,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(144:30-144:35),"graph"
1056,MEMBERCALLEXPRESSION,"size",Ex21.java(144:30-144:42),"graph.size()"
1057,LITERAL,"",Ex21.java(144:45-144:46),"1"
1058,DECLAREDREFERENCEEXPRESSION,"size",Ex21.java(144:36-144:40),"size"
1059,METHODDECLARATION,"size",Ex21.java(379:6-381:7),"public int size() {
	        return mGraph.size();
	    }"
1060,CONSTRUCTEXPRESSION,"",Ex21.java(116:51-116:91),"new HashMap<T, FibonacciHeap.Entry<T>>()"
1061,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(124:14-124:19),"graph"
1062,DECLAREDREFERENCEEXPRESSION,"startNode",Ex21.java(139:27-139:36),"startNode"
1063,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(139:38-139:43),"graph"
1064,DECLAREDREFERENCEEXPRESSION,"pq",Ex21.java(139:45-139:47),"pq"
1065,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(139:49-139:55),"result"
1066,DECLAREDREFERENCEEXPRESSION,"entries",Ex21.java(139:57-139:64),"entries"
1067,MEMBERCALLEXPRESSION,"next",Ex21.java(128:24-128:47),"graph.iterator().next()"
1068,DECLAREDREFERENCEEXPRESSION,"next",Ex21.java(128:41-128:45),"next"
1069,MEMBERCALLEXPRESSION,"iterator",Ex21.java(128:24-128:40),"graph.iterator()"
1070,DECLAREDREFERENCEEXPRESSION,"iterator",Ex21.java(128:30-128:38),"iterator"
1071,METHODDECLARATION,"iterator",Ex21.java(370:6-372:7),"public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }"
1072,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(128:24-128:29),"graph"
1073,NEWEXPRESSION,"",Ex21.java(119:38-119:73),"new Ex21().new UndirectedGraph<T>()"
1074,CONSTRUCTEXPRESSION,"",Ex21.java(119:38-119:73),"new Ex21().new UndirectedGraph<T>()"
1075,NEWEXPRESSION,"",Ex21.java(110:32-110:54),"new FibonacciHeap<T>()"
1076,NEWEXPRESSION,"",Ex21.java(116:51-116:91),"new HashMap<T, FibonacciHeap.Entry<T>>()"
1077,MEMBERCALLEXPRESSION,"isEmpty",Ex21.java(124:14-124:29),"graph.isEmpty()"
1078,RETURNSTATEMENT,"",Ex21.java(125:14-125:28),"return result;"
1079,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(125:21-125:27),"result"
1080,DECLAREDREFERENCEEXPRESSION,"isEmpty",Ex21.java(124:20-124:27),"isEmpty"
1081,METHODDECLARATION,"isEmpty",Ex21.java(388:6-390:7),"public boolean isEmpty() {
	        return mGraph.isEmpty();
	    }"
1082,DECLAREDREFERENCEEXPRESSION,"addNode",Ex21.java(134:17-134:24),"addNode"
1083,DECLAREDREFERENCEEXPRESSION,"startNode",Ex21.java(134:25-134:34),"startNode"
1084,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(134:10-134:16),"result"
1085,VARIABLEDECLARATION,"this",,""
1086,COMPOUNDSTATEMENT,"",Ex21.java(225:88-250:7),"{
	        /* Start off by scanning over all edges emanating from our node. */
	        for (Map.Entry<T, Double> arc : graph.edgesFrom(node).entrySet()) {
	            /* Given this arc, there are four possibilities.
	             *
	             * 1. This endpoint has already been added to the graph.  If so,
	             *    we ignore the edge since it would form a cycle.
	             * 2. This endpoint is not in the graph and has never been in
	             *    the heap.  Then we add it to the heap.
	             * 3. This endpoint is in the graph, but this is a better edge.
	             *    Then we use decreaseKey to update its priority.
	             * 4. This endpoint is in the graph, but there is a better edge
	             *    to it.  In that case, we similarly ignore it.
	             */
	            if (result.containsNode(arc.getKey())) continue; // Case 1

	            if (!entries.containsKey(arc.getKey())) { // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }
	            else if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }

	            // Case 4 handled implicitly by doing nothing.
	        }
	    }"
1087,PARAMVARIABLEDECLARATION,"node",Ex21.java(222:47-222:53),"T node"
1088,PARAMVARIABLEDECLARATION,"graph",Ex21.java(222:55-222:79),"UndirectedGraph<T> graph"
1089,PARAMVARIABLEDECLARATION,"pq",Ex21.java(223:47-223:66),"FibonacciHeap<T> pq"
1090,PARAMVARIABLEDECLARATION,"result",Ex21.java(224:47-224:72),"UndirectedGraph<T> result"
1091,PARAMVARIABLEDECLARATION,"entries",Ex21.java(225:47-225:85),"Map<T, FibonacciHeap.Entry<T>> entries"
1092,DECLAREDREFERENCEEXPRESSION,"graph",Ex21.java(227:42-227:47),"graph"
1093,RETURNSTATEMENT,"",,""
1094,FOREACHSTATEMENT,"",Ex21.java(227:10-249:11),"for (Map.Entry<T, Double> arc : graph.edgesFrom(node).entrySet()) {
	            /* Given this arc, there are four possibilities.
	             *
	             * 1. This endpoint has already been added to the graph.  If so,
	             *    we ignore the edge since it would form a cycle.
	             * 2. This endpoint is not in the graph and has never been in
	             *    the heap.  Then we add it to the heap.
	             * 3. This endpoint is in the graph, but this is a better edge.
	             *    Then we use decreaseKey to update its priority.
	             * 4. This endpoint is in the graph, but there is a better edge
	             *    to it.  In that case, we similarly ignore it.
	             */
	            if (result.containsNode(arc.getKey())) continue; // Case 1

	            if (!entries.containsKey(arc.getKey())) { // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }
	            else if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }

	            // Case 4 handled implicitly by doing nothing.
	        }"
1095,DECLARATIONSTATEMENT,"",Ex21.java(227:15-227:39),"Map.Entry<T, Double> arc"
1096,MEMBERCALLEXPRESSION,"entrySet",Ex21.java(227:42-227:74),"graph.edgesFrom(node).entrySet()"
1097,COMPOUNDSTATEMENT,"",Ex21.java(227:76-249:11),"{
	            /* Given this arc, there are four possibilities.
	             *
	             * 1. This endpoint has already been added to the graph.  If so,
	             *    we ignore the edge since it would form a cycle.
	             * 2. This endpoint is not in the graph and has never been in
	             *    the heap.  Then we add it to the heap.
	             * 3. This endpoint is in the graph, but this is a better edge.
	             *    Then we use decreaseKey to update its priority.
	             * 4. This endpoint is in the graph, but there is a better edge
	             *    to it.  In that case, we similarly ignore it.
	             */
	            if (result.containsNode(arc.getKey())) continue; // Case 1

	            if (!entries.containsKey(arc.getKey())) { // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }
	            else if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }

	            // Case 4 handled implicitly by doing nothing.
	        }"
1098,VARIABLEDECLARATION,"arc",Ex21.java(227:36-227:39),"arc"
1099,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(239:18-239:24),"result"
1100,IFSTATEMENT,"",Ex21.java(239:14-239:62),"if (result.containsNode(arc.getKey())) continue;"
1101,IFSTATEMENT,"",Ex21.java(241:14-246:15),"if (!entries.containsKey(arc.getKey())) { // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }
	            else if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }"
1102,COMPOUNDSTATEMENT,"",Ex21.java(241:54-243:15),"{ // Case 2
	                entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));
	            }"
1103,COMPOUNDSTATEMENT,"",Ex21.java(244:81-246:15),"{ // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }"
1104,IFSTATEMENT,"",Ex21.java(244:19-246:15),"if (entries.get(arc.getKey()).getPriority() > arc.getValue()) { // Case 3
	                pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());
	            }"
1105,UNARYOPERATOR,"!",Ex21.java(241:18-241:52),"!entries.containsKey(arc.getKey())"
1106,DECLAREDREFERENCEEXPRESSION,"entries",Ex21.java(242:18-242:25),"entries"
1107,DECLAREDREFERENCEEXPRESSION,"entries",Ex21.java(244:23-244:30),"entries"
1108,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(241:19-241:52),"entries.containsKey(arc.getKey())"
1109,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(241:27-241:38),"containsKey"
1110,MEMBERCALLEXPRESSION,"getKey",Ex21.java(241:39-241:51),"arc.getKey()"
1111,DECLAREDREFERENCEEXPRESSION,"entries",Ex21.java(241:19-241:26),"entries"
1112,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(241:39-241:42),"arc"
1113,DECLAREDREFERENCEEXPRESSION,"getKey",Ex21.java(241:43-241:49),"getKey"
1114,BINARYOPERATOR,">",Ex21.java(244:23-244:79),"entries.get(arc.getKey()).getPriority() > arc.getValue()"
1115,DECLAREDREFERENCEEXPRESSION,"pq",Ex21.java(245:18-245:20),"pq"
1116,MEMBERCALLEXPRESSION,"getPriority",Ex21.java(244:23-244:62),"entries.get(arc.getKey()).getPriority()"
1117,MEMBERCALLEXPRESSION,"getValue",Ex21.java(244:65-244:79),"arc.getValue()"
1118,DECLAREDREFERENCEEXPRESSION,"getPriority",Ex21.java(244:49-244:60),"getPriority"
1119,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(244:65-244:68),"arc"
1120,MEMBERCALLEXPRESSION,"get",Ex21.java(244:23-244:48),"entries.get(arc.getKey())"
1121,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(244:31-244:34),"get"
1122,MEMBERCALLEXPRESSION,"getKey",Ex21.java(244:35-244:47),"arc.getKey()"
1123,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(244:35-244:38),"arc"
1124,DECLAREDREFERENCEEXPRESSION,"getKey",Ex21.java(244:39-244:45),"getKey"
1125,DECLAREDREFERENCEEXPRESSION,"getValue",Ex21.java(244:69-244:77),"getValue"
1126,MEMBERCALLEXPRESSION,"decreaseKey",Ex21.java(245:18-245:76),"pq.decreaseKey(entries.get(arc.getKey()), arc.getValue());"
1127,DECLAREDREFERENCEEXPRESSION,"decreaseKey",Ex21.java(245:21-245:32),"decreaseKey"
1128,METHODDECLARATION,"decreaseKey",,""
1129,MEMBERCALLEXPRESSION,"getValue",Ex21.java(245:60-245:74),"arc.getValue()"
1130,DECLAREDREFERENCEEXPRESSION,"getValue",Ex21.java(245:64-245:72),"getValue"
1131,PARAMVARIABLEDECLARATION,"v1",,""
1132,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(245:60-245:63),"arc"
1133,MEMBERCALLEXPRESSION,"get",Ex21.java(245:33-245:58),"entries.get(arc.getKey())"
1134,DECLAREDREFERENCEEXPRESSION,"entries",Ex21.java(245:33-245:40),"entries"
1135,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(245:41-245:44),"get"
1136,PARAMVARIABLEDECLARATION,"v0",,""
1137,MEMBERCALLEXPRESSION,"getKey",Ex21.java(245:45-245:57),"arc.getKey()"
1138,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(245:45-245:48),"arc"
1139,DECLAREDREFERENCEEXPRESSION,"getKey",Ex21.java(245:49-245:55),"getKey"
1140,MEMBERCALLEXPRESSION,"put",Ex21.java(242:18-242:86),"entries.put(arc.getKey(), pq.enqueue(arc.getKey(), arc.getValue()));"
1141,DECLAREDREFERENCEEXPRESSION,"put",Ex21.java(242:26-242:29),"put"
1142,MEMBERCALLEXPRESSION,"enqueue",Ex21.java(242:44-242:84),"pq.enqueue(arc.getKey(), arc.getValue())"
1143,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(242:30-242:33),"arc"
1144,DECLAREDREFERENCEEXPRESSION,"enqueue",Ex21.java(242:47-242:54),"enqueue"
1145,METHODDECLARATION,"enqueue",,""
1146,MEMBERCALLEXPRESSION,"getValue",Ex21.java(242:69-242:83),"arc.getValue()"
1147,DECLAREDREFERENCEEXPRESSION,"pq",Ex21.java(242:44-242:46),"pq"
1148,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(242:55-242:58),"arc"
1149,MEMBERCALLEXPRESSION,"getKey",Ex21.java(242:30-242:42),"arc.getKey()"
1150,MEMBERCALLEXPRESSION,"getKey",Ex21.java(242:55-242:67),"arc.getKey()"
1151,DECLAREDREFERENCEEXPRESSION,"getKey",Ex21.java(242:59-242:65),"getKey"
1152,PARAMVARIABLEDECLARATION,"k0",,""
1153,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(242:69-242:72),"arc"
1154,DECLAREDREFERENCEEXPRESSION,"getValue",Ex21.java(242:73-242:81),"getValue"
1155,PARAMVARIABLEDECLARATION,"v1",,""
1156,DECLAREDREFERENCEEXPRESSION,"getKey",Ex21.java(242:34-242:40),"getKey"
1157,MEMBERCALLEXPRESSION,"containsNode",Ex21.java(239:18-239:51),"result.containsNode(arc.getKey())"
1158,CONTINUESTATEMENT,"",Ex21.java(239:53-239:62),"continue;"
1159,DECLAREDREFERENCEEXPRESSION,"containsNode",Ex21.java(239:25-239:37),"containsNode"
1160,MEMBERCALLEXPRESSION,"getKey",Ex21.java(239:38-239:50),"arc.getKey()"
1161,DECLAREDREFERENCEEXPRESSION,"getKey",Ex21.java(239:42-239:48),"getKey"
1162,DECLAREDREFERENCEEXPRESSION,"arc",Ex21.java(239:38-239:41),"arc"
1163,UNINITIALIZEDVALUE,"Uninitialized Value",,""
1164,DECLAREDREFERENCEEXPRESSION,"entrySet",Ex21.java(227:64-227:72),"entrySet"
1165,MEMBERCALLEXPRESSION,"edgesFrom",Ex21.java(227:42-227:63),"graph.edgesFrom(node)"
1166,DECLAREDREFERENCEEXPRESSION,"edgesFrom",Ex21.java(227:48-227:57),"edgesFrom"
1167,DECLAREDREFERENCEEXPRESSION,"node",Ex21.java(227:58-227:62),"node"
1168,ARRAYCREATIONEXPRESSION,"",Ex21.java(15:30-15:47),"new boolean [101]"
1169,LITERAL,"",Ex21.java(15:43-15:46),"101"
1170,FIELDDECLARATION,"this",,""
1171,FIELDDECLARATION,"mGraph",Ex21.java(259:6-259:85),"mGraph = new HashMap<T, Map<T, Double>>()"
1172,METHODDECLARATION,"addNode",Ex21.java(268:6-276:7),"public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashMap<T, Double>());
	        return true;
	    }"
1173,METHODDECLARATION,"addEdge",Ex21.java(290:6-298:7),"public void addEdge(T one, T two, double length) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Add the edge in both directions. */
	        mGraph.get(one).put(two, length);
	        mGraph.get(two).put(one, length);
	    }"
1174,METHODDECLARATION,"removeEdge",Ex21.java(309:6-317:7),"public void removeEdge(T one, T two) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Remove the edges from both adjacency lists. */
	        mGraph.get(one).remove(two);
	        mGraph.get(two).remove(one);
	    }"
1175,METHODDECLARATION,"edgeCost",Ex21.java(330:6-344:7),"public double edgeCost(T one, T two) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");     
	        
	        /* Look up the edge between the two. */
	        Double result = mGraph.get(one).get(two);

	        /* If there is no edge here, report an error. */
	        if (result == null)
	            throw new NoSuchElementException(""Edge does not exist in the graph."");

	        /* Otherwise return the cost. */
	        return result;
	    }"
1176,METHODDECLARATION,"edgesFrom",Ex21.java(354:6-361:7),"public Map<T, Double> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Map<T, Double> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException(""Source node does not exist."");

	        return Collections.unmodifiableMap(arcs);
	    }"
1177,METHODDECLARATION,"containsNode",Ex21.java(369:6-371:7),"public boolean containsNode(T node) {
	        return mGraph.containsKey(node);
	    }"
1178,METHODDECLARATION,"iterator",Ex21.java(378:6-380:7),"public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }"
1179,METHODDECLARATION,"size",Ex21.java(387:6-389:7),"public int size() {
	        return mGraph.size();
	    }"
1180,METHODDECLARATION,"isEmpty",Ex21.java(396:6-398:7),"public boolean isEmpty() {
	        return mGraph.isEmpty();
	    }"
1181,CONSTRUCTORDECLARATION,"Ex21.UndirectedGraph",,""
1182,VARIABLEDECLARATION,"this",,""
1183,COMPOUNDSTATEMENT,"",Ex21.java(330:43-344:7),"{
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");     
	        
	        /* Look up the edge between the two. */
	        Double result = mGraph.get(one).get(two);

	        /* If there is no edge here, report an error. */
	        if (result == null)
	            throw new NoSuchElementException(""Edge does not exist in the graph."");

	        /* Otherwise return the cost. */
	        return result;
	    }"
1184,PARAMVARIABLEDECLARATION,"one",Ex21.java(330:29-330:34),"T one"
1185,PARAMVARIABLEDECLARATION,"two",Ex21.java(330:36-330:41),"T two"
1186,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(332:15-332:21),"this"
1187,RETURNSTATEMENT,"",Ex21.java(343:10-343:24),"return result;"
1188,IFSTATEMENT,"",Ex21.java(332:10-333:83),"if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");"
1189,DECLARATIONSTATEMENT,"",Ex21.java(336:10-336:51),"Double result = mGraph.get(one).get(two);"
1190,IFSTATEMENT,"",Ex21.java(339:10-340:84),"if (result == null)
	            throw new NoSuchElementException(""Edge does not exist in the graph."");"
1191,VARIABLEDECLARATION,"result",Ex21.java(336:17-336:50),"result = mGraph.get(one).get(two)"
1192,UNARYOPERATOR,"throw",Ex21.java(340:14-340:84),"throw new NoSuchElementException(""Edge does not exist in the graph."");"
1193,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(339:14-339:20),"result"
1194,BINARYOPERATOR,"||",Ex21.java(332:14-332:66),"!mGraph.containsKey(one) || !mGraph.containsKey(two)"
1195,UNARYOPERATOR,"throw",Ex21.java(333:14-333:83),"throw new NoSuchElementException(""Both nodes must be in the graph."");"
1196,LITERAL,"",Ex21.java(333:47-333:81),"""Both nodes must be in the graph."""
1197,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(336:26-336:32),"this"
1198,NEWEXPRESSION,"",Ex21.java(333:20-333:82),"new NoSuchElementException(""Both nodes must be in the graph."")"
1199,CONSTRUCTEXPRESSION,"",Ex21.java(333:20-333:82),"new NoSuchElementException(""Both nodes must be in the graph."")"
1200,UNARYOPERATOR,"!",Ex21.java(332:14-332:38),"!mGraph.containsKey(one)"
1201,UNARYOPERATOR,"!",Ex21.java(332:42-332:66),"!mGraph.containsKey(two)"
1202,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(332:43-332:66),"mGraph.containsKey(two)"
1203,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(332:50-332:61),"containsKey"
1204,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(332:62-332:65),"two"
1205,MEMBEREXPRESSION,"mGraph",Ex21.java(332:43-332:49),"mGraph"
1206,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(332:43-332:49),"this"
1207,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(332:15-332:38),"mGraph.containsKey(one)"
1208,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(332:22-332:33),"containsKey"
1209,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(332:34-332:37),"one"
1210,MEMBEREXPRESSION,"mGraph",Ex21.java(332:15-332:21),"mGraph"
1211,MEMBERCALLEXPRESSION,"get",Ex21.java(336:26-336:50),"mGraph.get(one).get(two)"
1212,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(336:42-336:45),"get"
1213,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(336:46-336:49),"two"
1214,MEMBERCALLEXPRESSION,"get",Ex21.java(336:26-336:41),"mGraph.get(one)"
1215,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(336:33-336:36),"get"
1216,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(336:37-336:40),"one"
1217,MEMBEREXPRESSION,"mGraph",Ex21.java(336:26-336:32),"mGraph"
1218,DECLAREDREFERENCEEXPRESSION,"result",Ex21.java(343:17-343:23),"result"
1219,BINARYOPERATOR,"==",Ex21.java(339:14-339:28),"result == null"
1220,LITERAL,"",Ex21.java(340:47-340:82),"""Edge does not exist in the graph."""
1221,LITERAL,"",Ex21.java(339:24-339:28),"null"
1222,NEWEXPRESSION,"",Ex21.java(340:20-340:83),"new NoSuchElementException(""Edge does not exist in the graph."")"
1223,CONSTRUCTEXPRESSION,"",Ex21.java(340:20-340:83),"new NoSuchElementException(""Edge does not exist in the graph."")"
1224,NEWEXPRESSION,"",Ex21.java(259:52-259:84),"new HashMap<T, Map<T, Double>>()"
1225,CONSTRUCTEXPRESSION,"",Ex21.java(259:52-259:84),"new HashMap<T, Map<T, Double>>()"
1226,VARIABLEDECLARATION,"this",,""
1227,COMPOUNDSTATEMENT,"",Ex21.java(309:43-317:7),"{
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Remove the edges from both adjacency lists. */
	        mGraph.get(one).remove(two);
	        mGraph.get(two).remove(one);
	    }"
1228,PARAMVARIABLEDECLARATION,"one",Ex21.java(309:29-309:34),"T one"
1229,PARAMVARIABLEDECLARATION,"two",Ex21.java(309:36-309:41),"T two"
1230,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(311:15-311:21),"this"
1231,RETURNSTATEMENT,"",,""
1232,IFSTATEMENT,"",Ex21.java(311:10-312:83),"if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");"
1233,MEMBERCALLEXPRESSION,"remove",Ex21.java(315:10-315:38),"mGraph.get(one).remove(two);"
1234,MEMBERCALLEXPRESSION,"remove",Ex21.java(316:10-316:38),"mGraph.get(two).remove(one);"
1235,UNARYOPERATOR,"throw",Ex21.java(312:14-312:83),"throw new NoSuchElementException(""Both nodes must be in the graph."");"
1236,BINARYOPERATOR,"||",Ex21.java(311:14-311:66),"!mGraph.containsKey(one) || !mGraph.containsKey(two)"
1237,LITERAL,"",Ex21.java(312:47-312:81),"""Both nodes must be in the graph."""
1238,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(315:10-315:16),"this"
1239,UNARYOPERATOR,"!",Ex21.java(311:14-311:38),"!mGraph.containsKey(one)"
1240,UNARYOPERATOR,"!",Ex21.java(311:42-311:66),"!mGraph.containsKey(two)"
1241,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(311:15-311:38),"mGraph.containsKey(one)"
1242,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(311:43-311:49),"this"
1243,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(311:22-311:33),"containsKey"
1244,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(311:34-311:37),"one"
1245,MEMBEREXPRESSION,"mGraph",Ex21.java(311:15-311:21),"mGraph"
1246,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(311:43-311:66),"mGraph.containsKey(two)"
1247,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(311:50-311:61),"containsKey"
1248,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(311:62-311:65),"two"
1249,MEMBEREXPRESSION,"mGraph",Ex21.java(311:43-311:49),"mGraph"
1250,NEWEXPRESSION,"",Ex21.java(312:20-312:82),"new NoSuchElementException(""Both nodes must be in the graph."")"
1251,CONSTRUCTEXPRESSION,"",Ex21.java(312:20-312:82),"new NoSuchElementException(""Both nodes must be in the graph."")"
1252,DECLAREDREFERENCEEXPRESSION,"remove",Ex21.java(316:26-316:32),"remove"
1253,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(316:33-316:36),"one"
1254,MEMBERCALLEXPRESSION,"get",Ex21.java(316:10-316:25),"mGraph.get(two)"
1255,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(316:17-316:20),"get"
1256,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(316:21-316:24),"two"
1257,MEMBEREXPRESSION,"mGraph",Ex21.java(316:10-316:16),"mGraph"
1258,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(316:10-316:16),"this"
1259,DECLAREDREFERENCEEXPRESSION,"remove",Ex21.java(315:26-315:32),"remove"
1260,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(315:33-315:36),"two"
1261,MEMBERCALLEXPRESSION,"get",Ex21.java(315:10-315:25),"mGraph.get(one)"
1262,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(315:17-315:20),"get"
1263,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(315:21-315:24),"one"
1264,MEMBEREXPRESSION,"mGraph",Ex21.java(315:10-315:16),"mGraph"
1265,VARIABLEDECLARATION,"this",,""
1266,COMPOUNDSTATEMENT,"",Ex21.java(354:46-361:7),"{
	        /* Check that the node exists. */
	        Map<T, Double> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException(""Source node does not exist."");

	        return Collections.unmodifiableMap(arcs);
	    }"
1267,PARAMVARIABLEDECLARATION,"node",Ex21.java(354:38-354:44),"T node"
1268,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(356:32-356:38),"this"
1269,RETURNSTATEMENT,"",Ex21.java(360:10-360:51),"return Collections.unmodifiableMap(arcs);"
1270,DECLARATIONSTATEMENT,"",Ex21.java(356:10-356:49),"Map<T, Double> arcs = mGraph.get(node);"
1271,IFSTATEMENT,"",Ex21.java(357:10-358:78),"if (arcs == null)
	            throw new NoSuchElementException(""Source node does not exist."");"
1272,VARIABLEDECLARATION,"arcs",Ex21.java(356:25-356:48),"arcs = mGraph.get(node)"
1273,UNARYOPERATOR,"throw",Ex21.java(358:14-358:78),"throw new NoSuchElementException(""Source node does not exist."");"
1274,MEMBERCALLEXPRESSION,"get",Ex21.java(356:32-356:48),"mGraph.get(node)"
1275,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(356:39-356:42),"get"
1276,DECLAREDREFERENCEEXPRESSION,"node",Ex21.java(356:43-356:47),"node"
1277,MEMBEREXPRESSION,"mGraph",Ex21.java(356:32-356:38),"mGraph"
1278,DECLAREDREFERENCEEXPRESSION,"arcs",Ex21.java(357:14-357:18),"arcs"
1279,BINARYOPERATOR,"==",Ex21.java(357:14-357:26),"arcs == null"
1280,LITERAL,"",Ex21.java(358:47-358:76),"""Source node does not exist."""
1281,DECLAREDREFERENCEEXPRESSION,"arcs",Ex21.java(360:45-360:49),"arcs"
1282,NEWEXPRESSION,"",Ex21.java(358:20-358:77),"new NoSuchElementException(""Source node does not exist."")"
1283,CONSTRUCTEXPRESSION,"",Ex21.java(358:20-358:77),"new NoSuchElementException(""Source node does not exist."")"
1284,LITERAL,"",Ex21.java(357:22-357:26),"null"
1285,STATICCALLEXPRESSION,"unmodifiableMap",Ex21.java(360:17-360:50),"Collections.unmodifiableMap(arcs)"
1286,VARIABLEDECLARATION,"this",,""
1287,COMPOUNDSTATEMENT,"",Ex21.java(378:36-380:7),"{
	        return mGraph.keySet().iterator();
	    }"
1288,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(379:17-379:23),"this"
1289,RETURNSTATEMENT,"",Ex21.java(379:10-379:44),"return mGraph.keySet().iterator();"
1290,MEMBERCALLEXPRESSION,"iterator",Ex21.java(379:17-379:43),"mGraph.keySet().iterator()"
1291,DECLAREDREFERENCEEXPRESSION,"iterator",Ex21.java(379:33-379:41),"iterator"
1292,MEMBERCALLEXPRESSION,"keySet",Ex21.java(379:17-379:32),"mGraph.keySet()"
1293,DECLAREDREFERENCEEXPRESSION,"keySet",Ex21.java(379:24-379:30),"keySet"
1294,MEMBEREXPRESSION,"mGraph",Ex21.java(379:17-379:23),"mGraph"
1295,VARIABLEDECLARATION,"this",,""
1296,COMPOUNDSTATEMENT,"",Ex21.java(268:37-276:7),"{
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashMap<T, Double>());
	        return true;
	    }"
1297,PARAMVARIABLEDECLARATION,"node",Ex21.java(268:29-268:35),"T node"
1298,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(270:14-270:20),"this"
1299,RETURNSTATEMENT,"",Ex21.java(275:10-275:22),"return true;"
1300,IFSTATEMENT,"",Ex21.java(270:10-271:27),"if (mGraph.containsKey(node))
	            return false;"
1301,MEMBERCALLEXPRESSION,"put",Ex21.java(274:10-274:53),"mGraph.put(node, new HashMap<T, Double>());"
1302,DECLAREDREFERENCEEXPRESSION,"put",Ex21.java(274:17-274:20),"put"
1303,LITERAL,"",Ex21.java(275:17-275:21),"true"
1304,NEWEXPRESSION,"",Ex21.java(274:27-274:51),"new HashMap<T, Double>()"
1305,DECLAREDREFERENCEEXPRESSION,"node",Ex21.java(274:21-274:25),"node"
1306,CONSTRUCTEXPRESSION,"",Ex21.java(274:27-274:51),"new HashMap<T, Double>()"
1307,MEMBEREXPRESSION,"mGraph",Ex21.java(274:10-274:16),"mGraph"
1308,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(274:10-274:16),"this"
1309,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(270:14-270:38),"mGraph.containsKey(node)"
1310,RETURNSTATEMENT,"",Ex21.java(271:14-271:27),"return false;"
1311,LITERAL,"",Ex21.java(271:21-271:26),"false"
1312,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(270:21-270:32),"containsKey"
1313,DECLAREDREFERENCEEXPRESSION,"node",Ex21.java(270:33-270:37),"node"
1314,MEMBEREXPRESSION,"mGraph",Ex21.java(270:14-270:20),"mGraph"
1315,VARIABLEDECLARATION,"this",,""
1316,COMPOUNDSTATEMENT,"",Ex21.java(396:31-398:7),"{
	        return mGraph.isEmpty();
	    }"
1317,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(397:17-397:23),"this"
1318,RETURNSTATEMENT,"",Ex21.java(397:10-397:34),"return mGraph.isEmpty();"
1319,MEMBERCALLEXPRESSION,"isEmpty",Ex21.java(397:17-397:33),"mGraph.isEmpty()"
1320,DECLAREDREFERENCEEXPRESSION,"isEmpty",Ex21.java(397:24-397:31),"isEmpty"
1321,MEMBEREXPRESSION,"mGraph",Ex21.java(397:17-397:23),"mGraph"
1322,VARIABLEDECLARATION,"this",,""
1323,COMPOUNDSTATEMENT,"",Ex21.java(290:55-298:7),"{
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");

	        /* Add the edge in both directions. */
	        mGraph.get(one).put(two, length);
	        mGraph.get(two).put(one, length);
	    }"
1324,PARAMVARIABLEDECLARATION,"one",Ex21.java(290:26-290:31),"T one"
1325,PARAMVARIABLEDECLARATION,"two",Ex21.java(290:33-290:38),"T two"
1326,PARAMVARIABLEDECLARATION,"length",Ex21.java(290:40-290:53),"double length"
1327,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(292:15-292:21),"this"
1328,RETURNSTATEMENT,"",,""
1329,IFSTATEMENT,"",Ex21.java(292:10-293:83),"if (!mGraph.containsKey(one) || !mGraph.containsKey(two))
	            throw new NoSuchElementException(""Both nodes must be in the graph."");"
1330,MEMBERCALLEXPRESSION,"put",Ex21.java(296:10-296:43),"mGraph.get(one).put(two, length);"
1331,MEMBERCALLEXPRESSION,"put",Ex21.java(297:10-297:43),"mGraph.get(two).put(one, length);"
1332,UNARYOPERATOR,"throw",Ex21.java(293:14-293:83),"throw new NoSuchElementException(""Both nodes must be in the graph."");"
1333,BINARYOPERATOR,"||",Ex21.java(292:14-292:66),"!mGraph.containsKey(one) || !mGraph.containsKey(two)"
1334,LITERAL,"",Ex21.java(293:47-293:81),"""Both nodes must be in the graph."""
1335,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(296:10-296:16),"this"
1336,UNARYOPERATOR,"!",Ex21.java(292:14-292:38),"!mGraph.containsKey(one)"
1337,UNARYOPERATOR,"!",Ex21.java(292:42-292:66),"!mGraph.containsKey(two)"
1338,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(292:43-292:66),"mGraph.containsKey(two)"
1339,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(292:50-292:61),"containsKey"
1340,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(292:62-292:65),"two"
1341,MEMBEREXPRESSION,"mGraph",Ex21.java(292:43-292:49),"mGraph"
1342,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(292:43-292:49),"this"
1343,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(292:15-292:38),"mGraph.containsKey(one)"
1344,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(292:22-292:33),"containsKey"
1345,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(292:34-292:37),"one"
1346,MEMBEREXPRESSION,"mGraph",Ex21.java(292:15-292:21),"mGraph"
1347,NEWEXPRESSION,"",Ex21.java(293:20-293:82),"new NoSuchElementException(""Both nodes must be in the graph."")"
1348,CONSTRUCTEXPRESSION,"",Ex21.java(293:20-293:82),"new NoSuchElementException(""Both nodes must be in the graph."")"
1349,DECLAREDREFERENCEEXPRESSION,"put",Ex21.java(296:26-296:29),"put"
1350,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(297:10-297:16),"this"
1351,DECLAREDREFERENCEEXPRESSION,"length",Ex21.java(296:35-296:41),"length"
1352,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(296:30-296:33),"two"
1353,MEMBERCALLEXPRESSION,"get",Ex21.java(296:10-296:25),"mGraph.get(one)"
1354,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(296:17-296:20),"get"
1355,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(296:21-296:24),"one"
1356,MEMBEREXPRESSION,"mGraph",Ex21.java(296:10-296:16),"mGraph"
1357,DECLAREDREFERENCEEXPRESSION,"put",Ex21.java(297:26-297:29),"put"
1358,DECLAREDREFERENCEEXPRESSION,"length",Ex21.java(297:35-297:41),"length"
1359,DECLAREDREFERENCEEXPRESSION,"one",Ex21.java(297:30-297:33),"one"
1360,MEMBERCALLEXPRESSION,"get",Ex21.java(297:10-297:25),"mGraph.get(two)"
1361,DECLAREDREFERENCEEXPRESSION,"get",Ex21.java(297:17-297:20),"get"
1362,DECLAREDREFERENCEEXPRESSION,"two",Ex21.java(297:21-297:24),"two"
1363,MEMBEREXPRESSION,"mGraph",Ex21.java(297:10-297:16),"mGraph"
1364,VARIABLEDECLARATION,"this",,""
1365,COMPOUNDSTATEMENT,"",Ex21.java(387:24-389:7),"{
	        return mGraph.size();
	    }"
1366,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(388:17-388:23),"this"
1367,RETURNSTATEMENT,"",Ex21.java(388:10-388:31),"return mGraph.size();"
1368,MEMBERCALLEXPRESSION,"size",Ex21.java(388:17-388:30),"mGraph.size()"
1369,DECLAREDREFERENCEEXPRESSION,"size",Ex21.java(388:24-388:28),"size"
1370,MEMBEREXPRESSION,"mGraph",Ex21.java(388:17-388:23),"mGraph"
1371,VARIABLEDECLARATION,"this",,""
1372,COMPOUNDSTATEMENT,"",Ex21.java(369:42-371:7),"{
	        return mGraph.containsKey(node);
	    }"
1373,PARAMVARIABLEDECLARATION,"node",Ex21.java(369:34-369:40),"T node"
1374,DECLAREDREFERENCEEXPRESSION,"this",Ex21.java(370:17-370:23),"this"
1375,RETURNSTATEMENT,"",Ex21.java(370:10-370:42),"return mGraph.containsKey(node);"
1376,MEMBERCALLEXPRESSION,"containsKey",Ex21.java(370:17-370:41),"mGraph.containsKey(node)"
1377,DECLAREDREFERENCEEXPRESSION,"containsKey",Ex21.java(370:24-370:35),"containsKey"
1378,DECLAREDREFERENCEEXPRESSION,"node",Ex21.java(370:36-370:40),"node"
1379,MEMBEREXPRESSION,"mGraph",Ex21.java(370:17-370:23),"mGraph"
